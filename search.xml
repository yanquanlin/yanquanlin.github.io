<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[弱水三千只取一瓢饮]]></title>
    <url>%2F2029%2F02%2F03%2F%E5%BC%B1%E6%B0%B4%E4%B8%89%E5%8D%83%E5%8F%AA%E5%8F%96%E4%B8%80%E7%93%A2%E9%A5%AE%2F</url>
    <content type="text"><![CDATA[2019/2/3 这应该是最为生气的一天，早上8点多才睡着，早饭午饭也没吃，你知道我有多伤心吗？原来在我之外还有一个男朋友的存在，原来你的第一次早就不在了，原来我一直就是小三般的存在，如果不是登了你的qq号，可能很久都没办法知道吧，原来空间情侣，游戏情侣不是你的朋友，而是你的另一个男朋友，说实话，真的受不了这个打击甚至想分手，可是后来，在朋友都劝我分手的时候，我妥协了，因为我真的是喜欢你啊，因为喜欢你，舍不得放弃，舍不得离开你，何怡然，我也不知道这样做是对还是错，但是我，从来就没有想过抛弃你或者说离开你，也没有过二心，每次说我有小学妹什么的，我只是不想让你知道的时候不明事实，不想你生气，可是你这样，让我怎么相信你？你们在一起一年多，和我在一起就半年，所以，真的，挺失望的，最后原谅你一次，希望，以后我们都能好好的，希望能平平淡淡的过完余生，我觉得自己以前是足够信任你的，就算你不给我看你的手机 ，不告诉我你的密码，我也只是觉得，你和你朋友之间有什么我不太适合知道的小秘密，真的挺失落的，何怡然，最后一次，希望不要辜负了我的期待，今天开了这个博文，希望以后里面能够充满开心快乐的事，希望这是我们之间的最后一件不愉快。何怡然，我爱你，一辈子，你若不离，我定不弃，以后，我们好好地在一起。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019 fjut校赛 J(kmp|exkmp|ntt)]]></title>
    <url>%2F2019%2F05%2F13%2F2019-fjut%E6%A0%A1%E8%B5%9B-J-kmp-exkmp-ntt%2F</url>
    <content type="text"><![CDATA[链接第六集，想不到你这个浓眉大眼的都叛变革命了 题意给你一个母串和子串，如果子串改变一个字符能匹配母串，则输出yes，否者输出no 题解方法很多，大佬用的ntt和exkmp，菜鸡的我用的kmp，对母串每个位置分别求个前缀最长能匹配的子串位置，然后存下来，然后对它跑后缀，查在它前面两个的位置匹配的前缀的位置，如果前缀加后缀和加1（容错的1个）等于m（子串长度），则ok，后面就是细节了，因为匹配是最长，可能会出现循环节多了的情况，比如abcabc我们匹配到了abcabc,但是只需要abc，所以长度还得减去循环节，查看是否相等，还有如果匹配长度等于m-1并且后面还有字符则一定也可以，并且如果完全匹配也可以 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;string.h&gt;#include&lt;stdio.h&gt;int flag;int n,m,next[1000005],next2[1000005];char a[1000005],b[1000005];char aa[1000005],bb[1000005];int ab[1000005];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j]; next[i+1]=j+1; &#125;&#125;void Getnext2()&#123; next2[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;bb[i]!=bb[j]) j=next2[j]; next2[i+1]=j+1; &#125;&#125;void KMP()&#123; for(int i=0,j=0;i&lt;n;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=b[j]) j=next[j]; ab[i]=j; if(j+2==m&amp;&amp;i&lt;n-1||(j==-1&amp;&amp;j+2==m&amp;&amp;i&lt;n)) &#123; flag=1; &#125; if(j==m-1) flag=1; &#125;&#125;void KMP2()&#123; for(int i=0,j=0;i&lt;n;i++,j++) &#123; while(j!=-1&amp;&amp;aa[i]!=bb[j]) j=next2[j]; if(ab[n-i-3]+j+3==m&amp;&amp;n&gt;=i+3) &#123; flag=1; &#125; else if(ab[n-i-3]+j+3&gt;m&amp;&amp;n&gt;=i+3) &#123; if((ab[n-i-3]+1)%(ab[n-i-3]+1-next[ab[n-i-3]+1])==0&amp;&amp;(ab[n-i-3]+j+3-m)%((ab[n-i-3]+1-next[ab[n-i-3]+1]))==0) &#123; flag=1; &#125; if((j+1)%(j+1-next2[j+1])==0&amp;&amp;(ab[n-i-3]+j+3-m)%(j+1-next2[j+1])==0) &#123; flag=1; &#125; &#125; if(j+2==m&amp;&amp;i&lt;n-1||(j==-1&amp;&amp;j+2==m&amp;&amp;i&lt;n)) &#123; flag=1; &#125; &#125;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; flag=0; scanf(&quot;%s%s&quot;,a,b); //a-&gt;long b-&gt;short n=strlen(a);m=strlen(b); //if(m==1) //flag=1; Getnext(); KMP(); for(int i=0;i&lt;n;i++) &#123; aa[i]=a[n-i-1]; &#125; for(int i=0;i&lt;m;i++) &#123; bb[i]=b[m-i-1]; &#125; Getnext2(); KMP2(); if(m&gt;n) flag=0; if(flag==1) printf(&quot;YES\n&quot;); else printf(&quot;NO\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>fjut</category>
      </categories>
      <tags>
        <tag>-kmp -exkmp -ntt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 4110 Strings in the Pocket (马拉车求回文串数量）]]></title>
    <url>%2F2019%2F04%2F29%2FZOJ-4110-Strings-in-the-Pocket-%E9%A9%AC%E6%8B%89%E8%BD%A6%E6%B1%82%E5%9B%9E%E6%96%87%E4%B8%B2%E6%95%B0%E9%87%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链接K- Strings in the Pocket 题意给你两个字符串ab，可以对a串中的子串进行翻转，问有多少对lr使得翻转后的a串等于b串 题解如果a串等于b串，则就是求a串中的回文串的数目（串的数目可能很多，得开longlong ）如果不一样，一定翻转第一个不相等和最后一个不相等的位置，然后判断翻转后是否相等，然后两边看能不能加特判l==r 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;char a[2000005],b[2000005],s_new[5000005];int p[5000005]; int init()&#123; int len=strlen(a),j=2; s_new[0]=&apos;$&apos;,s_new[1]=&apos;#&apos;; for(int i=0;i&lt;len;i++)&#123; s_new[j++]=a[i]; s_new[j++]=&apos;#&apos;; &#125; s_new[j]=0; return j;&#125;long long int manacher()&#123; long long int res=0; int len=init(),mx=0,id; for(int i=0;i&lt;len;i++)&#123; if(mx&gt;i)p[i]=min(p[2*id-i],mx-i); else p[i]=1; while(s_new[i-p[i]]==s_new[i+p[i]])p[i]++; if(mx&lt;i+p[i])mx=i+p[i],id=i; res+=p[i]/2; &#125; return res;&#125;int main()&#123; int i,j,m,n; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot; %s %s&quot;,a,b); n=strlen(a); int flag=-1,maxx=0; for(i=0;i&lt;n;i++) &#123; if(a[i]!=b[i]&amp;&amp;flag==-1) &#123; flag=i; &#125; if(a[i]!=b[i]) &#123; maxx=i; &#125; &#125; if(flag==-1) &#123; long long int cnt=manacher();//除以2是因为这里的字符串之间插入了‘#’ printf(&quot;%lld\n&quot;,cnt); &#125; else &#123; int cnt=1,jj; for(j=flag-1,jj=maxx+1;j&gt;=0,jj&lt;n;j--,jj++) &#123; if(a[j]!=a[jj]||j&lt;0||jj&gt;=n) break; else cnt++; &#125; if(maxx==flag) cnt=0; else &#123; int k; for(j=flag,k=maxx;j&lt;=maxx;j++,k--) &#123; if(a[j]!=b[k]) break; &#125; if(j&lt;=maxx) cnt=0; &#125; printf(&quot;%d\n&quot;,cnt); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>zoj</category>
      </categories>
      <tags>
        <tag>Manacher</tag>
        <tag>浙江省省赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sort的使用]]></title>
    <url>%2F2019%2F01%2F31%2Fsort%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[C++ 中sort 函数及 cmp 自定义规则的使用需要用到的头文件12#include&lt;algorithm&gt;using namespace std; 需要传两到三个参数，数据类型不限，只要是内定义了大小比较符，我们可以只传两个参数（区间首地址，区间尾地址的下一个地址）例如sort(a,a+n),对从a[0]到a[n-1]的数据进行从小到大的排序，如果想要改变排序方式或者对内部未定义大小比较符的进行排序，我们需要再传个比较函数cmp进去。，例如：12345678bool cmp(node x,node y)&#123; if(x.a!=y.a) return x.a if(x.b!=y.b) return x.b&gt;y.b; return return x.c&gt;y.c;&#125; sort(arr,arr+n,cmp); 先按a值升序排列，如果a值相同，再按b值降序排列，如果b还相同，就按c降序排列。]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Palindrome (Manacher)]]></title>
    <url>%2F2019%2F01%2F30%2FPalindrome-Manacher%2F</url>
    <content type="text"><![CDATA[链接A - Palindrome 题意输出最长的子回文串的长度 题解马拉车模板题 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int Manacher(string s) &#123; // Insert &apos;#&apos; string t = &quot;$#&quot;; for (int i = 0; i &lt; s.size(); ++i) &#123; t += s[i]; t += &quot;#&quot;; &#125; // Process t vector&lt;int&gt; p(t.size(), 0); int mx = 0, id = 0, resLen = 0, resCenter = 0; for (int i = 1; i &lt; t.size(); ++i) &#123; p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1; while (t[i + p[i]] == t[i - p[i]]) ++p[i]; if (mx &lt; i + p[i]) &#123; mx = i + p[i]; id = i; &#125; if (resLen &lt; p[i]) &#123; resLen = p[i]; resCenter = i; &#125; &#125; return resLen - 1;&#125;int main() &#123; string s1; int k=0; while(1) &#123; k++; cin&gt;&gt;s1; if(s1[0]==&apos;E&apos;) break; else &#123; cout&lt;&lt;&quot;Case &quot;&lt;&lt;k&lt;&lt;&quot;: &quot;&lt;&lt;Manacher(s1)&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>VJ</category>
      </categories>
      <tags>
        <tag>VJ</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[E1. Array and Segments(暴力)]]></title>
    <url>%2F2019%2F01%2F28%2FE1-Array-and-Segments-%E6%9A%B4%E5%8A%9B-1%2F</url>
    <content type="text"><![CDATA[链接E1. Array and Segments (Easy version) 题意一串长为n的数串，m个区间，选择区间使得该区间的数减一，求最后修改完后数串(max-min)的最大值。 题解方法很多，e1是简单，直接暴力即可，对每一位都当做最大值来进行区间选择，我们知道如果使得（max-min)的值最大，则max越大，min越小越好，由于没有加的操作，所以我们只能间接让max最大，即当选定为max后，如果区间包含该位置则不选该区间，如果不包含，则选区间，因为他可能有两种情况，使min更小或者不影响结果。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;int a[1000005];int b[1000005];int l[1000005];int r[1000005];int main()&#123; int i,j,m,n,k,sum=0,minn=1000000,memi=1,memn=0,qum; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(i=1;i&lt;=m;i++) &#123; scanf(&quot;%d%d&quot;,&amp;l[i],&amp;r[i]); &#125; for(i=1;i&lt;=n;i++) &#123; qum=0; for(j=1;j&lt;=n;j++) b[j]=a[j]; for(j=1;j&lt;=m;j++) &#123; if(l[j]&lt;=i&amp;&amp;r[j]&gt;=i) &#123; &#125; else &#123; qum++; for(k=l[j];k&lt;=r[j];k++) b[k]--; &#125; &#125; minn=b[1]; for(j=2;j&lt;=n;j++) &#123; if(b[j]&lt;minn) minn=b[j]; &#125; if(sum&lt;a[i]-minn) &#123; memn=qum; memi=i; sum=a[i]-minn; &#125; &#125; printf(&quot;%d\n&quot;,sum); printf(&quot;%d\n&quot;,memn); int dum=0; for(i=1;i&lt;=m;i++) &#123; if(l[i]&lt;=memi&amp;&amp;r[i]&gt;=memi) &#123; &#125; else &#123; dum++; if(dum==memn) printf(&quot;%d\n&quot;,i); else printf(&quot;%d &quot;,i); &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[D. Game with modulo(交互，二分)]]></title>
    <url>%2F2019%2F01%2F28%2FD-Game-with-modulo-%E4%BA%A4%E4%BA%92%EF%BC%8C%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[链接D. Game with modulo 题意给你一个a，你可以输入x,y进行询问，返回”x”, 如果 (x mod a)≥(y mod a)，返回”y”,如果(x mod a)&lt;(y mod a)，最多60次询问，请设计一个方案求出a的值。 题解分块二分，首先0到1询问，如果返回为x则证明a为1，然后询问（1，2）（2，4）（4，8）……（1e9,2e9)，如果返回为x则证明a在该区间，对区间进行二分查询。 最开始想的是直接1到2e9进行二分，发现会超过60次。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;long long int a[50],l,r,m;char f[100];int main()&#123; int i,j,n; a[0]=0; a[1]=1; for(i=2;i&lt;=32;i++) &#123; a[i]=a[i-1]*2; &#125; while(scanf(&quot; %s&quot;,f)!=EOF) &#123; if(f[0]!=&apos;s&apos;) break; char c; for(i=0;i&lt;=30;i++) &#123; printf(&quot;? %lld %lld\n&quot;,a[i],a[i+1]); fflush(stdout); scanf(&quot; %c&quot;,&amp;c); if(c==&apos;x&apos;) break; &#125; if(a[i]==0) &#123; printf(&quot;! 1\n&quot;); fflush(stdout); &#125; else &#123; l=a[i]+1,r=a[i+1]; while(l&lt;r) &#123; m=(l+r)/2; printf(&quot;? %lld %lld\n&quot;,m,l-1); fflush(stdout); scanf(&quot; %c&quot;,&amp;c); if(c==&apos;x&apos;) l=m+1; else r=m; &#125; printf(&quot;! %lld\n&quot;,l); fflush(stdout); &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>二分</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[acm模板]]></title>
    <url>%2F2019%2F01%2F27%2Facm%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[其他位运算1234567891011121314151617#include&lt;iostream&gt;using namespace std;int main()&#123; int n=15,m=8;//1111，1000 unsigned int x=8,y=7; cout&lt;&lt;__builtin_popcount(n)&lt;&lt;endl;//判断n中有几个1 cout&lt;&lt;__builtin_parity(n)&lt;&lt;endl;//判断n中1的个数的奇偶性,奇数输出1，偶数输出0 cout&lt;&lt;__builtin_parity(m)&lt;&lt;endl; cout&lt;&lt;__builtin_ffs(n)&lt;&lt;endl;//判断n的二进制末尾最后一个1的位置 cout&lt;&lt;__builtin_ffs(m)&lt;&lt;endl; cout&lt;&lt;__builtin_ctzll(n)&lt;&lt;endl;//判断n的二进制末尾后面0的个数，当n为0时，和n的类型有关 cout&lt;&lt;__builtin_ctz(m)&lt;&lt;endl; cout&lt;&lt;__builtin_clz(x)&lt;&lt;endl;//前导0的个数(为32位） cout&lt;&lt;__builtin_clz(y)&lt;&lt;endl; return 0; &#125; 博弈nim博弈123456789101112131415//读入n，表示有从物品数分别1到n的n堆物品，假设n个数存在数组f[]中，当n很大的时候异或和 int xor_n(int n)//从1到n的异或和&#123; int t = n &amp; 3; if (t &amp; 1) return t / 2 ^ 1; return t / 2 ^ n;&#125;int Nim_Game(int n)//有必胜策略返回1，nim博弈 &#123; int flag=0; for(int i=1;i&lt;=n;i++) flag^=xor_n(f[i]); if(flag) return 1; return 0;&#125; sg函数sg(x)=sg(mem(y));y为x的后继，例如x的后继为a,b,c，那么SG(x)=mex{SG(a),SG(b),SG(c)}，当sg(x)==0时,代表当前点为必败.对于多种状态，sg（x)=sg(x1)^sg(x2)^….; sg打表1234567891011121314151617181920212223//f[]：可以取走的石子个数//sg[]:0~n的SG函数值//hash[]:mex&#123;&#125;int f[N],sg[N],hash[N]; void getSG(int n)&#123; int i,j; memset(sg,0,sizeof(sg)); for(i=1;i&lt;=n;i++) &#123; memset(hash,0,sizeof(hash)); for(j=1;f[j]&lt;=i;j++) hash[sg[i-f[j]]]=1;//标记，f[j]表示能够取的，i-f[i]表示他的后继 for(j=0;j&lt;=n;j++) //求mes&#123;&#125;中未出现的最小的非负整数 &#123; if(hash[j]==0) &#123; sg[i]=j; break; &#125; &#125; &#125;&#125; dfs123456789101112131415161718192021222324252627//注意 S数组要按从小到大排序 SG函数要初始化为-1 对于每个集合只需初始化1遍//n是集合s的大小 S[i]是定义的特殊取法规则的数组int s[110],sg[10010],n;int SG_dfs(int x)&#123; int i; if(sg[x]!=-1) return sg[x]; bool vis[110]; memset(vis,0,sizeof(vis)); for(i=0;i&lt;n;i++) &#123; if(x&gt;=s[i]) &#123; SG_dfs(x-s[i]); vis[sg[x-s[i]]]=1; &#125; &#125; int e; for(i=0;;i++) if(!vis[i]) &#123; e=i; break; &#125; return sg[x]=e;&#125; 数据结构线段树线段树的单点修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const int maxn=1e6+5;int a[maxn]; //存每个数的值struct node&#123; int sum; int ll,rr;&#125;tree[maxn*4];void Pushup(int id) //区间合并&#123; tree[id].sum=tree[id*2].sum+tree[id*2+1].sum;&#125;void Pushdown() //区间下放，进行区间修改的时候用到&#123;&#125;void Build(int id,int ll,int rr) //建树&#123; tree[id].ll=ll; tree[id].rr=rr; if(ll==rr) &#123; tree[id].sum=a[ll]; return; &#125; int mid=(ll+rr)/2; //mid=ll+rr&gt;&gt;1; Build(id*2,ll,mid); Build(id*2+1,mid+1,rr); //Build(id&lt;&lt;1,ll,mid); //Build(id&lt;&lt;1|1,mid+1,rr); Pushup(id);&#125;void Update(int id,int x,int y) //修改&#123; if(tree[id].ll==tree[id].rr) &#123; tree[id].sum=y; return; &#125; int mid=(tree[id].ll+tree[id].rr)/2; if(x&lt;=mid) Update(id*2,x,y); else Update(id*2+1,x,y); Pushup(id);&#125;int Query(int id,int x,int y) //查询&#123; if(x&lt;=tree[id].ll&amp;&amp;tree[id].rr&lt;=y)//到头的情况 return tree[id].sum; int mid=(tree[id].ll+tree[id].rr)/2; if(y&lt;=mid) //只需要访问左边 return Query(id*2,x,y); else if(x&gt;=mid+1) return Query(id*2+1,x,y); else return Query(id*2,x,y)+Query(id*2+1,x,y);&#125; 线段树的区间修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const int maxn=1e6+5;long long int a[maxn];long long int lazy[maxn*4]; //存每个数的值struct node&#123; long long int sum; long long int ll,rr;&#125;tree[maxn*4];void Pushup(int id) //区间合并&#123; tree[id].sum=tree[id*2].sum+tree[id*2+1].sum;&#125;void Pushdown(int id) //区间下放，进行区间修改的时候用到&#123; if(lazy[id]) &#123; tree[id*2].sum+=lazy[id]*(tree[id*2].rr-tree[id*2].ll+1); tree[id*2+1].sum+=lazy[id]*(tree[id*2+1].rr-tree[id*2+1].ll+1); lazy[id*2]+=lazy[id]; lazy[id*2+1]+=lazy[id]; lazy[id]=0; &#125;&#125;void Build(int id,int ll,int rr) //建树&#123; lazy[id]=0; tree[id].ll=ll; tree[id].rr=rr; if(ll==rr) &#123; tree[id].sum=a[ll]; return; &#125; int mid=(ll+rr)/2; //mid=ll+rr&gt;&gt;1; //Build(ltree); //Build(rtree); Build(id&lt;&lt;1,ll,mid); Build(id&lt;&lt;1|1,mid+1,rr); Pushup(id);&#125;void Update(int id,int x,int y,int z) //修改&#123; if(x&lt;=tree[id].ll&amp;&amp;tree[id].rr&lt;=y) &#123; tree[id].sum+=z*(tree[id].rr-tree[id].ll+1); lazy[id]+=z; return; &#125; int mid=(tree[id].ll+tree[id].rr)/2; Pushdown(id); if(y&lt;=mid) Update(id*2,x,y,z); else if(x&gt;=mid+1) Update(id*2+1,x,y,z); else &#123; Update(id*2,x,y,z); Update(id*2+1,x,y,z); &#125; Pushup(id);&#125;long long int Query(int id,int x,int y) //查询&#123; if(x&lt;=tree[id].ll&amp;&amp;tree[id].rr&lt;=y)//到头的情况 return tree[id].sum; int mid=(tree[id].ll+tree[id].rr)/2; Pushdown(id); if(y&lt;=mid) //只需要访问左边 return Query(id*2,x,y); else if(x&gt;=mid+1) return Query(id*2+1,x,y); else return Query(id*2,x,y)+Query(id*2+1,x,y);&#125; 主席树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100000 + 5;int a[N], b[N], rt[N * 20], ls[N * 20], rs[N * 20], sum[N * 20];int n, k, tot, sz, ql, qr, x, q, T;void Build(int&amp; o, int l, int r)&#123; o = ++ tot; sum[o] = 0; if(l == r) return; int m = (l + r) &gt;&gt; 1; Build(ls[o], l, m); Build(rs[o], m + 1, r);&#125;void update(int&amp; o, int l, int r, int last, int p)&#123; o = ++ tot; ls[o] = ls[last]; rs[o] = rs[last]; sum[o] = sum[last] + 1; if(l == r) return; int m = (l + r) &gt;&gt; 1; if(p &lt;= m) update(ls[o], l, m, ls[last], p); else update(rs[o], m + 1, r, rs[last], p);&#125;int query(int ss, int tt, int l, int r, int k)&#123; if(l == r) return l; int m = (l + r) &gt;&gt; 1; int cnt = sum[ls[tt]] - sum[ls[ss]]; if(k &lt;= cnt) return query(ls[ss], ls[tt], l, m, k); else return query(rs[ss], rs[tt], m + 1, r, k - cnt);&#125;void work()&#123; scanf(&quot;%d%d%d&quot;, &amp;ql, &amp;qr, &amp;x); int ans = query(rt[ql - 1], rt[qr], 1, sz, x); printf(&quot;%d\n&quot;, b[ans]);&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;T); while(T--)&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, a + i), b[i] = a[i]; sort(b + 1, b + n + 1); sz = unique(b + 1, b + n + 1) - (b + 1); tot = 0; Build(rt[0],1, sz); //for(int i = 0; i &lt;= 4 * n; i ++)printf(&quot;%d,rt = %d,ls = %d, rs = %d, sum = %d\n&quot;, i, rt[i], ls[i], rs[i], sum[i]); for(int i = 1; i &lt;= n; i ++)a[i] = lower_bound(b + 1, b + sz + 1, a[i]) - b; for(int i = 1; i &lt;= n; i ++)update(rt[i], 1, sz, rt[i - 1], a[i]); //for(int i = 0; i &lt;= 5 * n; i ++)printf(&quot;%d,rt = %d,ls = %d, rs = %d, sum = %d\n&quot;, i, rt[i], ls[i], rs[i], sum[i]); while(q --)work(); &#125; return 0;&#125; 树状数组123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;int tree[1000000],n;int lowbit(int x)&#123; return x&amp;(-x);&#125;int Query(int x)//查询x项的前缀和 ； &#123; int res=0; while(x) &#123; res+=tree[x]; x-=lowbit(x); &#125; return res;&#125;void Add(int x,int v)//在x位加v； &#123; while(x&lt;=n) &#123; tree[x]+=v; x+=lowbit(x); &#125;&#125;int main()&#123; int a[100000],x; scanf(&quot;%d %d&quot;,&amp;n,&amp;x); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++) &#123; Add(i,a[i]);//树状数组的预处理，初始化 &#125; printf(&quot;%d\n&quot;,Query(x)); return 0;&#125; st表1234567891011121314void Init()&#123; for(int i = 0; i &lt; n; i++) d[i][0] = a[i]; for(int j = 1; (1&lt;&lt;j) &lt;= n; j++) for(int i = 0; i+(1&lt;&lt;j) &lt;= n; i++) d[i][j] = min(d[i][j-1], d[i+(1&lt;&lt;(j-1))][j-1]);&#125;int RMQ(int l, int r)&#123; int k = 0; while((1&lt;&lt;k) &lt;= r-l+1)k++; k--; return min(d[l][k], d[r-(1&lt;&lt;k)+1][k]);&#125; 字符串倍增求后缀数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//LCP(i,j)为suff(sa[i])与suff(sa[j])的最长公共前缀,LCP(i,k)=min(height[j]) 对于任意1&lt;i&lt;=j&lt;=k&lt;=n 相同的子串数目为height数组和（二分字符串长度）//x[i]为第i个元素的第一关键字，y[i]为第二关键字排名为i的数第一关键字的位置,rk[i]就表示起始位置的下标为i的后缀的排名,sa[i]表示排名为i的后缀的起始位置的下标，height[i]为LCP(i,i-1)#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define rint register int#define inv inline void#define ini inline int#define maxn 1000050using namespace std;char s[maxn];int y[maxn],x[maxn],c[maxn],sa[maxn],rk[maxn],height[maxn],wt[30];int n,m;inv get_SA() &#123; for (rint i=1; i&lt;=n; ++i) ++c[x[i]=s[i]];//赋值再加，相当于x[i]=s[i],++c[x[i]] for (rint i=2; i&lt;=m; ++i) c[i]+=c[i-1]; for (rint i=n; i&gt;=1; --i) sa[c[x[i]]--]=i;//排名 for (rint k=1; k&lt;=n; k&lt;&lt;=1) &#123; rint num=0; for (rint i=n-k+1; i&lt;=n; ++i) y[++num]=i;//第n-k+1到第n位是没有第二关键字的 所以排名在最前面 for (rint i=1; i&lt;=n; ++i) if (sa[i]&gt;k) y[++num]=sa[i]-k; for (rint i=1; i&lt;=m; ++i) c[i]=0; for (rint i=1; i&lt;=n; ++i) ++c[x[i]]; for (rint i=2; i&lt;=m; ++i) c[i]+=c[i-1]; //第一关键字排名为1~i的数有多少个 for (rint i=n; i&gt;=1; --i) sa[c[x[y[i]]]--]=y[i],y[i]=0;//基数排序 swap(x,y); x[sa[1]]=1; num=1; for (rint i=2; i&lt;=n; ++i) x[sa[i]]=(y[sa[i]]==y[sa[i-1]] &amp;&amp; y[sa[i]+k]==y[sa[i-1]+k]) ? num : ++num; if (num==n) break; m=num; &#125; for (rint i=1; i&lt;=n; ++i) printf(&quot;%d &quot;,sa[i]);&#125;inv get_height() &#123; rint k=0; for (rint i=1; i&lt;=n; ++i) rk[sa[i]]=i; for (rint i=1; i&lt;=n; ++i) &#123; if (rk[i]==1) continue;//第一名height为0 if (k) --k;//h[i]&gt;=h[i-1]-1; rint j=sa[rk[i]-1]; while (j+k&lt;=n &amp;&amp; i+k&lt;=n &amp;&amp; s[i+k]==s[j+k]) ++k; height[rk[i]]=k;//h[i]=height[rk[i]]; &#125; printf(&quot;\n&quot;); for (rint i=1; i&lt;=n; ++i) printf(&quot;%d &quot;,height[i]);&#125;int main() &#123; gets(s+1); n=strlen(s+1); m=122;//n表示原字符串长度，m表示字符个数，ascll(&apos;z&apos;)=122 get_SA(); get_height();&#125; 倍增lcp1234567891011121314151617181920212223242526272829303132333435#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;const int base=29;int n,sa[10001];char s[10001];unsigned long long ha[10001],power[10001]=&#123;1&#125;;unsigned long long HASH(int l,int r)&#123; return ha[r]-ha[l-1]*power[r-l+1];&#125;int LCP(int x,int y)&#123; int l=0,r=std::min(n-x+1,n-y+1),mid; while(l&lt;r) &#123; mid=(l+r+1)&gt;&gt;1; if(HASH(x,x+mid-1)==HASH(y,y+mid-1)) l=mid; else r=mid-1; &#125; return l;&#125;bool cmp(int x,int y)&#123; int z=LCP(x,y);return s[x+z]&lt;s[y+z];&#125;int main()&#123; scanf(&quot;%s&quot;,s+1); n=strlen(s+1); for(int i=1;i&lt;=n;i++) ha[i]=ha[i-1]*base+s[i]-&apos;a&apos;+1,power[i]=power[i-1]*base,sa[i]=i; std::sort(sa+1,sa+n+1,cmp); for(int i=2;i&lt;=n;i++) height[i]=LCP(sa[i-1],sa[i]);&#125; 回文树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const int MAXN = 100005 ; const int N = 26 ; struct Palindromic_Tree &#123; int next[MAXN][N] ;//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成 int fail[MAXN] ;//fail指针，失配后跳转到fail指针指向的节点 int cnt[MAXN] ; //当前节点表示的回文串在原串中出现了多少次(建树时求出的不是完全的，最后count()函数跑一遍以后才是正确的） int num[MAXN] ; //表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数 int len[MAXN] ;//len[i]表示节点i表示的回文串的长度（一个节点表示一个回文串） int S[MAXN];//存放添加的字符 int last ;//指向新添加一个字母后所形成的最长回文串表示的节点 int n ;//表示添加的字符个数 int p ;//表示添加的节点个数 int newnode ( int l ) &#123;//新建节点 for ( int i = 0 ; i &lt; N ; ++ i ) next[p][i] = 0 ; cnt[p] = 0 ; num[p] = 0 ; len[p] = l ; return p ++ ; &#125; void init () &#123;//初始化 p = 0 ; newnode ( 0 ) ; newnode ( -1 ) ; last = 0 ; n = 0 ; S[n] = -1 ;//开头放一个字符集中没有的字符，减少特判 fail[0] = 1 ; &#125; int get_fail ( int x ) &#123;//和KMP一样，失配后找一个尽量最长的 while ( S[n - len[x] - 1] != S[n] ) x = fail[x] ; return x ; &#125; void add ( int c ) &#123; c -= &apos;a&apos; ; S[++n] = c ; int cur = get_fail ( last ) ;//通过上一个回文串找这个回文串的匹配位置 if ( !next[cur][c] ) &#123;//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串 int now = newnode ( len[cur] + 2 ) ;//新建节点 fail[now] = next[get_fail ( fail[cur] )][c] ;//和AC自动机一样建立fail指针，以便失配后跳转 next[cur][c] = now ; num[now] = num[fail[now]] + 1 ; &#125; last = next[cur][c] ; cnt[last] ++ ; &#125; void count () &#123; for ( int i = p - 1 ; i &gt;= 0 ; -- i ) cnt[fail[i]] += cnt[i] ; //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！ &#125; &#125;run; int main()&#123; scanf(&quot;%s&quot;,&amp;S); run.init(); nn=strlen(S)-1; fo(int i=0,i&lt;=nn,i++)run.add(S[i],i); run.count();&#125; 字典树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;stdio.h&gt; #include&lt;string.h&gt;#define N 1000struct Node&#123; int sum;//前缀 int next[26];//子节点 void init()&#123; sum=0; memset(next,-1,sizeof next); &#125;&#125;tire[N];int tot;void insert(char *str)&#123; int len=strlen(str); int root=0; for(int i=0;i&lt;len;i++)&#123; int x=str[i]-&apos;a&apos;; if(tire[root].next[x]==-1) tire[root].next[x]=tot++; root=tire[root].next[x]; tire[root].sum++; &#125;&#125;int search(char *str)&#123; int len=strlen(str); int root=0; for(int i=0;i&lt;len;i++)&#123; int x=str[i]-&apos;a&apos;; if(tire[root].next[x]==-1) return 0; root=tire[root].next[x]; &#125; return tire[root].sum;&#125;void del(char *str,int word)&#123; int len=strlen(str); int root=0; if(word&lt;0) return; for(int i=0;i&lt;len;i++)&#123; int x=str[i]-&apos;a&apos;; if(tire[root].next[x]==-1) return; tire[root].sum-=word; root=tire[root].next[x]; &#125; tire[root].sum=0; for(int i=0;i&lt;26;i++) tire[root].next[i]=-1;&#125;int main()&#123; tot=1; for(int i=0;i&lt;N;i++) tire[i].init(); int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; char str[10],word[35]; scanf(&quot;%s%s&quot;,str,word); if(str[0]==&apos;i&apos;)//插入 insert(word); else if(str[0]==&apos;d&apos;)//删除 del(word,search(word)); else&#123;//查询 if(search(word)&gt;0) printf(&quot;Yes\n&quot;,search(word)); else printf(&quot;No\n&quot;); &#125; &#125; return 0;&#125; 01字符串123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int tol; //节点个数 LL val[32*MAXN]; //点的值 int ch[32*MAXN][2]; //边的值 void init()&#123; //初始化 tol=1; ch[0][0]=ch[0][1]=0;&#125;void insert(LL x)&#123; //往 01字典树中插入 x int u=0; for(int i=32;i&gt;=0;i--) &#123; int v=(x&gt;&gt;i)&amp;1; if(!ch[u][v]) &#123; //如果节点未被访问过 ch[tol][0]=ch[tol][1]=0; //将当前节点的边值初始化 val[tol]=0; //节点值为0，表示到此不是一个数 ch[u][v]=tol++; //边指向的节点编号 &#125; u=ch[u][v]; //下一节点 &#125; val[u]=x; //节点值为 x，即到此是一个数 &#125;void update(LL x,int add)&#123; //更新插入或删除 x后每个节点被访问的次数（1为加，-1为减） int u=0; for(int i=32;i&gt;=0;i--) &#123; int v=(x&gt;&gt;i)&amp;1; u=ch[u][v]; num[u]+=add; &#125;&#125;LL query(LL x)&#123; //查询所有数中和 x异或结果最大的数 int u=0; for(int i=32;i&gt;=0;i--) &#123; int v=(x&gt;&gt;i)&amp;1; //利用贪心策略，优先寻找和当前位不同的数 if(ch[u][v^1]) u=ch[u][v^1]; else u=ch[u][v]; &#125; return val[u]; //返回结果 &#125; 最小最大表示法字符串通过翻转使得字典序最小（最大）例如abc可以翻转成bca,cab.1234567891011121314151617181920int Get_min() &#123; int n = strlen(s); int i = 0,j = 1,k = 0,t; //表示从i开始k长度和从j开始k长度的字符串相同 while(i &lt; n &amp;&amp; j &lt; n &amp;&amp; k &lt; n) &#123; t = s[(i+k)%n] - s[(j+k)%n]; //t用来计算相对应位置上那个字典序较大 if(!t) k++;//字符相等的情况 else &#123; if(t &gt; 0) i += k+1;//i位置大,最大表示法: j += k+1 else j += k+1;//j位置大,最大表示法: i += k+1 if(i == j) j++; k = 0; &#125; &#125; return i &gt;j ?j :i;&#125; kmp12345678910111213141516171819202122232425262728#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[100001];char a[100001],b[100001];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j]; next[i+1]=j+1; &#125;&#125;void KMP()&#123; for(int i=0,j=0;i&lt;n;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=b[j]) j=next[j]; if(j==m-1) printf(&quot;%d\n&quot;,i-j+1); &#125;&#125;int main()&#123; scanf(&quot;%s%s&quot;,a,b); //a-&gt;long b-&gt;short n=strlen(a);m=strlen(b); Getnext(); KMP();&#125; ac自动机12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;const int N=500005;int T,n,tot,end[N],fail[N],son[N][26];char s[N*2];std::queue&lt;int&gt; Q;void init(int x)&#123; end[x]=0; for(int i=0;i&lt;26;i++) son[x][i]=0;&#125;void Add()&#123; scanf(&quot;%s&quot;,s); int len=strlen(s),pre=0; for(int i=0;i&lt;len;i++) &#123; if(!son[pre][s[i]-&apos;a&apos;]) init(son[pre][s[i]-&apos;a&apos;]=++tot); pre=son[pre][s[i]-&apos;a&apos;]; &#125; end[pre]++;&#125;void Build()&#123; Q.push(0); while(!Q.empty()) &#123; int x=Q.front();Q.pop(); for(int i=0;i&lt;26;i++) &#123; if(son[x][i]) &#123; Q.push(son[x][i]); fail[son[x][i]]=x?son[fail[x]][i]:0; &#125; else son[x][i]=x?son[fail[x]][i]:0; &#125; &#125;&#125;int Calc()&#123; scanf(&quot;%s&quot;,s); int len=strlen(s),pre=0,ans=0; for(int i=0;i&lt;len;i++) &#123; pre=son[pre][s[i]-&apos;a&apos;]; for(int j=pre;j;j=fail[j]) ans+=end[j],end[j]=0; &#125; return ans;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; init(tot=0); for(scanf(&quot;%d&quot;,&amp;n);n;n--) Add(); Build(); printf(&quot;%d\n&quot;,Calc()); &#125;&#125; Manacher推荐博客：Manacher’s Algorithm 马拉车算法1234567891011121314151617181920212223242526272829303132333435363738#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string Manacher(string s) &#123; // Insert &apos;#&apos; string t = &quot;$#&quot;;//在头插入$# for (int i = 0; i &lt; s.size(); ++i) &#123; t += s[i]; t += &quot;#&quot;;//s[i]的每个字母前后都插入# &#125; // Process t vector&lt;int&gt; p(t.size(), 0); int mx = 0, id = 0, resLen = 0, resCenter = 0; for (int i = 1; i &lt; t.size(); ++i) &#123;//两个指针mx,resLen，两个保存变量id,resCenter; resLen代表最长的回文串中心的半径，i代表最长的回文串 p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1;//p[i]存以该点为中心，回文串的半径（包含该点）(例$#1#2#2#1)最中间的#半径为4 //2*id-i是i关于id的对称点，如果mx-i&gt;p[j]，则为12321，id为3，mx为3，i为4，j为2，p[j]=1,p[i]也应该为1，i，j在id包围中且j的回文串也在id的包围中，所以i的回文串应该和j一样 //如果mx-i&lt;p[j]，也就是超出了id的包含范围，这个时候p[i]只能为mx-i，剩下的只能一个一个的匹配了 while (t[i + p[i]] == t[i - p[i]]) ++p[i];//回文串处理 if (mx &lt; i + p[i]) &#123; mx = i + p[i];//mx是回文串所能到达的最右边的位置 id = i; &#125; if (resLen &lt; p[i]) &#123; resLen = p[i]; resCenter = i; &#125; &#125; return s.substr((resCenter - resLen) / 2, resLen - 1);//返回最大的回文串，(resCenter - resLen) / 2为开始位置 ， resLen - 1为长度（包含了#） &#125;int main() &#123; string s1 = &quot;12212&quot;; cout &lt;&lt; Manacher(s1) &lt;&lt; endl; string s2 = &quot;122122&quot;; cout &lt;&lt; Manacher(s2) &lt;&lt; endl; string s = &quot;waabwswfd&quot;; cout &lt;&lt; Manacher(s) &lt;&lt; endl;&#125; 数学公式abs((x2-x1)(y3-y1)-(x3-x1)(y2-y1)) 计算几何多边形123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include&lt;stdio.h&gt;#define MAXN 1000#define offset 10000#define eps 1e-8#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)#define _sign(x) ((x)&gt;eps?1:((x)&lt;-eps?2:0))struct point&#123;double x,y;&#125;;struct line&#123;point a,b;&#125;;//叉乘 double xmult(point p1,point p2,point p0)&#123; return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125; //判定凸多边形,顶点按顺时针或逆时针给出,允许相邻边共线int is_convex(int n,point* p)&#123; int i,s[3]=&#123;1,1,1&#125;; for (i=0;i&lt;n&amp;&amp;s[1]|s[2];i++) s[_sign(xmult(p[(i+1)%n],p[(i+2)%n],p[i]))]=0; return s[1]|s[2];&#125;//判定凸多边形,顶点按顺时针或逆时针给出,不允许相邻边共线int is_convex_v2(int n,point* p)&#123; int i,s[3]=&#123;1,1,1&#125;; for (i=0;i&lt;n&amp;&amp;s[0]&amp;&amp;s[1]|s[2];i++) s[_sign(xmult(p[(i+1)%n],p[(i+2)%n],p[i]))]=0; return s[0]&amp;&amp;s[1]|s[2];&#125;//判点在凸多边形内或多边形边上,顶点按顺时针或逆时针给出int inside_convex(point q,int n,point* p)&#123; int i,s[3]=&#123;1,1,1&#125;; for (i=0;i&lt;n&amp;&amp;s[1]|s[2];i++) s[_sign(xmult(p[(i+1)%n],q,p[i]))]=0; return s[1]|s[2];&#125;//判点在凸多边形内,顶点按顺时针或逆时针给出,在多边形边上返回0int inside_convex_v2(point q,int n,point* p)&#123; int i,s[3]=&#123;1,1,1&#125;; for (i=0;i&lt;n&amp;&amp;s[0]&amp;&amp;s[1]|s[2];i++) s[_sign(xmult(p[(i+1)%n],q,p[i]))]=0; return s[0]&amp;&amp;s[1]|s[2];&#125;/*//判点在任意多边形内,顶点按顺时针或逆时针给出//on_edge表示点在多边形边上时的返回值,offset为多边形坐标上限int inside_polygon(point q,int n,point* p,int on_edge=1)&#123; point q2; int i=0,count; while (i&lt;n) for (count=i=0,q2.x=rand()+offset,q2.y=rand()+offset;i&lt;n;i++) if (zero(xmult(q,p[i],p[(i+1)%n]))&amp;&amp;(p[i].x-q.x)*(p[(i+1)%n].x-q.x)&lt;eps&amp;&amp;(p[i].y-q.y)*(p[(i+1)%n].y-q.y)&lt;eps) return on_edge; else if (zero(xmult(q,q2,p[i]))) break; else if (xmult(q,p[i],q2)*xmult(q,p[(i+1)%n],q2)&lt;-eps&amp;&amp;xmult(p[i],q,p[(i+1)%n])*xmult(p[i],q2,p[(i+1)%n])&lt;-eps) count++; return count&amp;1;&#125;inline int opposite_side(point p1,point p2,point l1,point l2)&#123; return xmult(l1,p1,l2)*xmult(l1,p2,l2)&lt;-eps;&#125;inline int dot_online_in(point p,point l1,point l2)&#123; return zero(xmult(p,l1,l2))&amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps&amp;&amp;(l1.y-p.y)*(l2.y-p.y)&lt;eps;&#125;//判线段在任意多边形内,顶点按顺时针或逆时针给出,与边界相交返回1int inside_polygon(point l1,point l2,int n,point* p)&#123; point t[MAXN],tt; int i,j,k=0; if (!inside_polygon(l1,n,p)||!inside_polygon(l2,n,p)) return 0; for (i=0;i&lt;n;i++) if (opposite_side(l1,l2,p[i],p[(i+1)%n])&amp;&amp;opposite_side(p[i],p[(i+1)%n],l1,l2)) return 0; else if (dot_online_in(l1,p[i],p[(i+1)%n])) t[k++]=l1; else if (dot_online_in(l2,p[i],p[(i+1)%n])) t[k++]=l2; else if (dot_online_in(p[i],l1,l2)) t[k++]=p[i]; for (i=0;i&lt;k;i++) for (j=i+1;j&lt;k;j++)&#123; tt.x=(t[i].x+t[j].x)/2; tt.y=(t[i].y+t[j].y)/2; if (!inside_polygon(tt,n,p)) return 0; &#125; return 1;&#125;point intersection(line u,line v)&#123; point ret=u.a; double t=((u.a.x-v.a.x)*(v.a.y-v.b.y)-(u.a.y-v.a.y)*(v.a.x-v.b.x)) /((u.a.x-u.b.x)*(v.a.y-v.b.y)-(u.a.y-u.b.y)*(v.a.x-v.b.x)); ret.x+=(u.b.x-u.a.x)*t; ret.y+=(u.b.y-u.a.y)*t; return ret;&#125;point barycenter(point a,point b,point c)&#123; line u,v; u.a.x=(a.x+b.x)/2; u.a.y=(a.y+b.y)/2; u.b=c; v.a.x=(a.x+c.x)/2; v.a.y=(a.y+c.y)/2; v.b=b; return intersection(u,v);&#125;*///多边形重心point barycenter(int n,point* p)&#123; point ret,t; double t1=0,t2; int i; ret.x=ret.y=0; for (i=1;i&lt;n-1;i++) if (fabs(t2=xmult(p[0],p[i],p[i+1]))&gt;eps)&#123; t=barycenter(p[0],p[i],p[i+1]); ret.x+=t.x*t2; ret.y+=t.y*t2; t1+=t2; &#125; if (fabs(t1)&gt;eps) ret.x/=t1,ret.y/=t1; return ret;&#125;int main()&#123; point a[1000]; point q; q.x=0,q.y=1; a[0].x=0,a[0].y=0; a[1].x=0,a[1].y=2; a[2].x=1,a[2].y=2; a[3].x=2,a[3].y=2; a[4].x=2,a[4].y=0; printf(&quot;%d\n&quot;,inside_convex_v2(q,5,a)); return 0;&#125; 面积1234567891011121314151617181920212223242526272829#include &lt;math.h&gt;struct point&#123;double x,y;&#125;;//计算cross product (P1-P0)x(P2-P0)(叉积） double xmult(point p1,point p2,point p0)&#123; return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125;double xmult(double x1,double y1,double x2,double y2,double x0,double y0)&#123; return (x1-x0)*(y2-y0)-(x2-x0)*(y1-y0);&#125;//计算三角形面积,输入三顶点double area_triangle(point p1,point p2,point p3)&#123; return fabs(xmult(p1,p2,p3))/2;&#125;double area_triangle(double x1,double y1,double x2,double y2,double x3,double y3)&#123; return fabs(xmult(x1,y1,x2,y2,x3,y3))/2;&#125;//计算三角形面积,输入三边长double area_triangle(double a,double b,double c)&#123; double s=(a+b+c)/2; return sqrt(s*(s-a)*(s-b)*(s-c));&#125;//计算多边形面积,顶点按顺时针或逆时针给出double area_polygon(int n,point* p)&#123; double s1=0,s2=0; int i; for (i=0;i&lt;n;i++) s1+=p[(i+1)%n].y*p[i].x,s2+=p[(i+1)%n].y*p[(i+2)%n].x; return fabs(s1-s2)/2;&#125; 三分123456789//这里以在一个凸性序列中查找元素为例int find(int l,int r,int v)//l存储上界，r存储下界，v即为目标元素&#123; if(l&gt;=r) return l;//返回答案 int midl=(l+r)&gt;&gt;1,midr=(midl+r)&gt;&gt;1; //比较midl与midr的大小 if(sum[midl]&gt;sum[midr]) return find(l,midr);//若midl大于midr，说明最大值在左侧区间 return find(midl,r);//反之，说明最大值在右侧区间&#125; 拉格朗日插值（已知f(x)上的n+1个点（xi,yi）i∈[0,n] ，求f(xi)）12345678910111213int lagrange(int n, int *x, int *y, int xi) &#123; int ans = 0; for (int i = 0; i &lt;= n; i++) &#123; int s1 = 1, s2 = 1; for (int j = 0; j &lt;= n; j++) if (i != j) &#123; s1 = 1ll*s1*(xi-x[j])%mod; s2 = 1ll*s2*(x[i]-x[j])%mod; &#125; ans = (1ll*ans+1ll*y[i]*s1%mod*quick_pow(s2, mod-2)%mod)%mod; &#125; return (ans+mod)%mod;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//求系数#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define O 1llusing namespace std;const int N=2005,mod=998244353;int n,k,x[N],y[N],num[N],tmp[N],res[N],inv[N];void Add(int &amp;x,int y)&#123; x+=y; if(x&gt;=mod) x-=mod;&#125;void exGCD(int a,int b,int &amp;x,int &amp;y)&#123; if(!b) x=1,y=0; else exGCD(b,a%b,y,x),y-=a/b*x;&#125;int Inv(int x)&#123; int xx,yy; exGCD(x,mod,xx,yy); Add(xx,mod); return xx;&#125;void Lagrange()&#123; for(int i=1;i&lt;=n;i++) &#123; int den=1,lst=0; for(int j=1;j&lt;=n;j++) if(i!=j) den=O*den*(x[i]-x[j]+mod)%mod; den=O*y[i]*Inv(den)%mod; for(int j=0;j&lt;n;j++) &#123; tmp[j]=O*(num[j]-lst+mod)*inv[i]%mod; Add(res[j],O*den*tmp[j]%mod),lst=tmp[j]; &#125; &#125;&#125;void Pre()&#123; num[0]=1; for(int i=1;i&lt;=n;swap(num,tmp),i++) &#123; tmp[0]=0; inv[i]=Inv(mod-x[i]); for(int j=1;j&lt;=i;j++) tmp[j]=num[j-1]; for(int j=0;j&lt;=i;j++) Add(tmp[j],O*num[j]*(mod-x[i])%mod); &#125;&#125;int Calc(int x)&#123; int ret=0,var=1; for(int i=0;i&lt;n;var=O*var*x%mod,i++) Add(ret,O*var*res[i]%mod); return ret;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]); Pre(),Lagrange(),printf(&quot;%d&quot;,Calc(k)); return 0;&#125; 素数筛1234567891011for(int i=2;i&lt;=n;i++)&#123; if(!prime[i]) isprime[++num]=i; for(int j=1;j&lt;=num&amp;&amp;i*isprime[j]&lt;=n;j++) &#123; prime[i*isprime[j]]=1; if(i%isprime[j]==0) break; &#125; &#125; 数论####二次剩余123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162/*hdu 3930 题意： 给定newx, k, m, 方程 (x^k)%m=newx, 求在模m意义下的所有解x。 限制： 0 &lt;= newx, m, k &lt;= 1.5*10^15; m是素数。 思路： N次剩余 */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;#define LL __int64#define PB push_backLL mul(LL a,LL b,LL m)&#123; LL ret = 0; a %= m; while(b)&#123; if(b &amp; 1) ret = (ret + a) % m; a = (a + a) % m; b &gt;&gt;= 1; &#125; return ret;&#125;LL a_b_MOD_c(LL a,LL b,LL m)&#123; LL ret = 1; a %= m; while(b)&#123; if(b&amp;1) ret = mul(ret,a,m); a = mul(a,a,m); b &gt;&gt;= 1; &#125; return ret;&#125;LL ext_gcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if(b==0) &#123; x=1, y=0; return a; &#125; LL ret= ext_gcd(b,a%b,y,x); y-= a/b*x; return ret;&#125;vector&lt;LL&gt; a;bool g_test(LL g,LL p)&#123; for(LL i=0;i&lt;a.size();++i) if(a_b_MOD_c(g,(p-1)/a[i],p)==1) return 0; return 1;&#125;LL pri_root(LL p)&#123; a.clear(); LL tmp=p-1; for(LL i=2;i&lt;=tmp/i;++i) if(tmp%i==0)&#123; a.push_back(i); while(tmp%i==0) tmp/=i; &#125; if(tmp!=1) a.push_back(tmp); LL g=1; while(true)&#123; if(g_test(g,p)) return g; ++g; &#125;&#125;const int HASH_MOD=9876543;LL key[HASH_MOD], val[HASH_MOD];int head[HASH_MOD], next[HASH_MOD];struct Hash&#123; int tot; void init()&#123; memset(head, -1, sizeof(head)); tot = 0; &#125; LL insert(LL x, LL y)&#123; int k = x % HASH_MOD; key[tot] = x; val[tot] = y; next[tot] = head[k]; head[k] = tot++; &#125; LL find(LL x)&#123; int k = x % HASH_MOD; for(int i = head[k]; i != -1; i = next[i]) if(key[i] == x) return val[i]; return -1; &#125;&#125;hs;//求解模方程a^x=b(mod m),n为素数,无解返回-1 //注意：要求0 &lt; a &lt; m; 0 &lt;= b &lt; m; 否则按题意自己转化。//复杂度O(sqrt(m))LL log_mod(LL a, LL b, LL m)&#123; hs.init(); LL s = ceil(sqrt(m + 0.5)); LL cur = 1; for (int i = 0; i &lt; s; ++i)&#123; if(hs.find(cur)==-1) hs.insert(cur,i); //记得先判重，在插入 cur = cur * a % m; &#125; LL v = a_b_MOD_c(a, (m - s - 1 + m) % m, m); for(int i = 0; i &lt; s; ++i)&#123; LL tmp = hs.find(b); if(tmp!=-1) return s * i + tmp; b=b*v%m; &#125; return -1;&#125;/*n次剩余 任务： 给定N, a, p, 求出(x^N)%p=a 在模p意义下的所有解x。 说明： 令g为p的原根，因为p为素数，所以phi(p)=p-1。 由原根的性质得： 如果g为p的原根，则：g^i mod p != g^j mod p (p为素数), 其中i != j且i, j介於1至(p-1)之间 所以，可以设g^y=x, g^t=a，则有： g^(y*N)%p=g^t 又由原根的性质： g^(y*N)%p=g^t -&gt; (y*N)%(p-1)=t (此方程可以由拓展欧几里得解) 另外g^t=a可以由离散对数求出 */vector&lt;LL&gt; residue(LL p, LL N, LL a)&#123; LL g = pri_root(p); g %= p; LL m = log_mod(g, a, p); vector&lt;LL&gt; ret; if(a == 0)&#123; ret.PB(0); return ret; &#125; if(m == -1) return ret; LL A = N, B = p - 1, C = m, x, y; LL d = ext_gcd(A, B, x, y); if(C % d != 0) return ret; x = x * (C / d) % B; LL delta = B / d; for(int i = 0; i &lt; d; ++i)&#123; x = ((x + delta) % B + B) % B; ret.PB(a_b_MOD_c(g, x, p)); &#125; sort(ret.begin(), ret.end()); ret.erase(unique(ret.begin(), ret.end()), ret.end()); return ret;&#125;int main()&#123; int cas = 0; LL k,m,newx; while(scanf(&quot;%I64d%I64d%I64d&quot;,&amp;k, &amp;m, &amp;newx)!=EOF)&#123; vector&lt;LL&gt; ans; ans = residue(m,k,newx); printf(&quot;case%d:\n&quot;,++cas); if(ans.size()==0) puts(&quot;-1&quot;); for(int i = 0; i &lt; ans.size(); ++i) printf(&quot;%I64d\n&quot;,ans[i]); &#125; return 0;&#125; 欧拉降幂123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960612^（2^（2^（2^2）））%p#include&lt;bits/stdc++.h&gt;#define lst long long#define ldb double#define N 10000050#define M 10000000using namespace std;const int Inf=1e9;int read()&#123; int s=0,m=0;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&apos;-&apos;)m=1;ch=getchar();&#125; while( isdigit(ch))s=(s&lt;&lt;3)+(s&lt;&lt;1)+(ch^48),ch=getchar(); return m?-s:s;&#125;int Q,tot;int phi[N],pri[N];void Prepare_Phi()&#123; phi[1]=1; for(int i=2;i&lt;=M;++i) &#123; if(!phi[i])pri[++tot]=i,phi[i]=i-1;//① for(int j=1;j&lt;=tot;++j) &#123; if(i*pri[j]&gt;M)break; if(!(i%pri[j])) &#123; phi[i*pri[j]]=phi[i]*pri[j];//② break; &#125;else phi[i*pri[j]]=phi[i]*(pri[j]-1);//③ &#125; &#125;&#125;lst qpow(lst x,lst y,lst mod)&#123; lst ret=1; while(y) &#123; if(y&amp;1)ret=ret*x%mod; x=x*x%mod,y&gt;&gt;=1; &#125;return ret;&#125;lst Solve(lst mod)&#123; if(mod==1)return 0; return qpow(2,Solve(phi[mod])+phi[mod],mod);&#125;int main()&#123; Prepare_Phi(); Q=read(); while(Q--) &#123; int p=read(); printf(&quot;%lld\n&quot;,Solve(p)); &#125; return 0;&#125; 阶乘因式分解（给你n,m，问n的阶乘中有多少个因子为m）12345while(n)&#123; sum+=n/m; n/=m;&#125; 连分数逼近法 3.245 的连分数是 [3; 4, 12, 4] 3+1/(4+(1/(12+1/4)))1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define ling 1e-8int main()&#123; double s; int a[1000]; //或者scanf(&quot;%d%d&quot;,&amp;a,&amp;b); 令s=a*1.0/(b*1.0); while (scanf(&quot;%lf&quot;,&amp;s)==1) &#123; int i=0; while (fabs(s)&gt;ling) &#123; a[i++]=(int)s; s=1/(s-(int)s); &#125; for (int j=0;j&lt;i-1;j++) cout&lt;&lt;a[j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; return 0;&#125; 欧拉函数欧拉函数是小于x的整数中与x互质的数的个数欧拉函数的几个性质1.对于质数p，φ(p)=p−1φ(p)=p−1 φ(p)=p-1φ(p)=p−1。2.若p为质数，n=pkn=pk n=p^kn=pk，则φ(n)φ(n) φ(n)φ(n)=pkpk p^kpk-pk−1pk−1 p^{k-1}pk−1。3.欧拉函数是积性函数，但不是完全积性函数。若m,n互质，则φ(m∗n)=φ(m)∗φ(n)φ(m∗n)=φ(m)∗φ(n) φ(mn)=φ(m)φ(n)φ(m∗n)=φ(m)∗φ(n)。特殊的，当m=2，n为奇数时，φ(2n)=φ(n)。4.当n&gt;2时，φ(n)是偶数。5.小于n的数中，与n互质的数的总和为：φ(n) n / 2 (n&gt;1)。6.n=∑d∣n φ(d)n=∑d∣n φ(d)即n的因数（包括1和它自己）的欧拉函数之和等于n。 单个求解欧拉函数12345678int eurlar(int x)&#123; int ret=x; for (int i=2;i&lt;=sqrt(x)&amp;&amp;x&gt;1;i++) if (x%i==0) &#123;ret=ret/i*(i-1); while (x%i==0) x/=i;&#125; if (x&gt;1) ret=ret/x*(x-1); return ret;&#125; 埃拉托斯特尼筛求欧拉函数(o(n)lnln)1234567891011121314void euler(int n)//phi[i]代表i的欧拉值，&#123; for (int i=1;i&lt;=n;i++) phi[i]=i; for (int i=2;i&lt;=n;i++) &#123; if (phi[i]==i)//这代表i是质数 &#123; for (int j=i;j&lt;=n;j+=i) &#123; phi[j]=phi[j]/i*(i-1);//把i的倍数更新掉 &#125; &#125; &#125;&#125; 欧拉筛求欧拉函数（o(n)）1234567891011121314151617181920212223void euler(int n)//flag[i]代表i是否为质数，prime存的质数，phi[i]代表i的欧拉值&#123; int num=0; phi[1]=1;//1要特判 for (int i=2;i&lt;=n;i++) &#123; if (flag[i]==0)//这代表i是质数 &#123; prime[++num]=i; phi[i]=i-1; &#125; for (int j=1;j&lt;=num&amp;&amp;prime[j]*i&lt;=n;j++)//经典的欧拉筛写法 &#123; flag[i*prime[j]]=1;//先把这个合数标记掉 if (i%prime[j]==0) &#123; phi[i*prime[j]]=phi[i]*prime[j];//若prime[j]是i的质因子，则根据计算公式，i已经包括i*prime[j]的所有质因子 break;//经典欧拉筛的核心语句，这样能保证每个数只会被自己最小的因子筛掉一次 &#125; else phi[i*prime[j]]=phi[i]*phi[prime[j]];//利用了欧拉函数是个积性函数的性质 &#125; &#125;&#125; 中国剩余定理中国剩余定理求x的最小非负整数解 //求M%A=a,M%B=b,…中的M，其中A,B,C…互质1234567891011121314int CRT(int a[],int m[],int n)&#123; int M = 1; int ans = 0; for(int i=1; i&lt;=n; i++) M *= m[i]; for(int i=1; i&lt;=n; i++)&#123; int x, y; int Mi = M / m[i]; ex_gcd(Mi, m[i], x, y); ans = (ans + Mi * x * a[i]) % M; &#125; if(ans &lt; 0) ans += M; return ans; &#125; 扩展中国剩余定理//求M%A=a,M%B=b,…中的M，其中A,B,C…不互质12345678910111213141516171819202122232425262728293031bool merge(LL a1, LL m1, LL a2, LL m2, LL &amp;a3, LL &amp;m3) &#123; LL d = gcd(m1, m2); LL c = a2 - a1; if(c % d) return false; c = (c % m2 + m2) % m2; m1 /= d; m2 /= d; c /= d; c *= Inv(m1, m2);//Inv为乘法逆元，数论常用内容——欧几里得算法与扩展欧几里得算法 c %= m2; c *= m1 * d; c += a1; m3 = m1 * m2 * d; a3 = (c % m3 + m3) % m3; return true; &#125; LL CRT(LL a[], LL m[], int n) &#123; LL a1 = a[1]; LL m1 = m[1]; for(int i=2; i&lt;=n; i++) &#123; LL a2 = a[i]; LL m2 = m[i]; LL m3, a3; if(!merge(a1, m1, a2, m2, a3, m3)) return -1; a1 = a3; m1 = m3; &#125; return (a1 % m1 + m1) % m1; &#125; 大素数 米勒拉宾素数测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const int S=8;//一般8-10个伪素数就行（斌巨的）long long mult_mod(long long a, long long b, long long c) &#123; a %= c; b %= c; long long ret = 0, tmp = a; while(b) &#123; if(b &amp; 1) &#123; ret += tmp; if(ret &gt; c) ret -= c; &#125; tmp &lt;&lt;= 1; if(tmp &gt; c) tmp -= c; b &gt;&gt;= 1; &#125; return ret;&#125;long long int quick_pow(long long int a,long long int n,long long int mod)//快速幂 &#123; long long ret = 1, tmp = a % mod; while(n) &#123; if(n &amp; 1) ret = mult_mod(ret, tmp, mod); tmp = mult_mod(tmp, tmp, mod); n &gt;&gt;= 1; &#125; return ret;&#125;bool check(long long a,long long n,long long x,long long t)&#123; long long ret = quick_pow(a, x, n); long long last = ret; for(int i = 1; i &lt;= t; ++i) &#123; ret = mult_mod(ret, ret, n); if(ret == 1 &amp;&amp; last != 1 &amp;&amp; last != n - 1) return true; last = ret; &#125; if(ret != 1) return true; else return false;&#125;bool Miller_Rabbin(long long int n)//米勒拉宾素数测试 &#123; if(n&lt;2) return false; if(n==2) return true; if((n&amp;1)==0) return false; long long int x=n-1; long long t=0; while((x&amp;1)==0) &#123; x&gt;&gt;=1;t++; &#125; srand(time(NULL)); for(int i=0;i&lt;S;i++)&#123; long long a=rand()%(n-1)+1; if(check(a,n,x,t)) return false; &#125; return true;&#125; //ab%mod(可能modmod超long long )long long ksc(long long a, long long b, long long mod){ long long res = 0; while(b){ if(b&amp;1) res = (res + a)%mod; (a&lt;&lt;=1)%=mod; b &gt;&gt;= 1; } return res;}12345678910111213141516171819202122232425262728293031323334353637383940ll quick_pow(ll a,ll b,ll r)//快速幂 &#123; ll ans = 1; while(b) &#123; if(b&amp;1)ans=(ans*a)%r; a = (a*a)%r; b&gt;&gt;=1; &#125; return ans;&#125;bool Miller_Rabbin(int n,int a)//米勒拉宾素数测试 &#123; int r=0,s=n-1,j; if(!(n%a)) return false; while(!(s&amp;1))&#123; s&gt;&gt;=1; r++; &#125; ll k=qpow(a,s,n); if(k==1) return true; for(j=0;j&lt;r;j++,k=k*k%n) if(k==n-1) return true; return false;&#125;bool IsPrime(int n)//判断是否是素数 &#123; int tab[]=&#123;2,3,5,7&#125;; for(int i=0;i&lt;4;i++) &#123; if(n==tab[i]) return true; if(!Miller_Rabbin(n,tab[i])) return false; &#125; return true;&#125; 佩尔方程（x^2-dy^2=1)连分数法12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a[20000];bool pell_minimum_solution(ll n,ll &amp;x0,ll &amp;y0)&#123;//求PELL方程最小整数解 ll m=(ll)sqrt((double)n);//M是N的平方根向下取整 if(m*m==n)return false;//当n是完全平方数则佩尔方程无解（不讨论正负一，零） //下面是把N用连分数形式存，B,C,TMP（即AI）的递推见解释以22为例参考 int i=0; //连分数的数位 a[i++]=m; //A0位整数部分m=4 ll b=m,c=1; //B=4即整数部分位,C=1即求RN时的分母 double sq=sqrt(n);//SQ是N的高精度根,相当于r0 double tmp;//tp在下面的循环就是rn do&#123; c=(n-b*b)/c; tmp=(sq+b)/c; a[i++]=(ll)(floor(tmp)); b=a[i-1]*c-b; //printf(&quot;%lld %lld %lld\n&quot;,a[i-1],b,c); &#125;while(a[i-1]!=2*a[0]);//当有一位等于整数两倍就结束 //下面就是要把连分数形式化成分子分母的形式，求PQ两个值 ll p=1,q=0; for(int j=i-2;j&gt;=0;j--)&#123; ll t=p; p=q+p*a[j]; q=t; //printf(&quot;a[%d]=%lld %lld %lld\n&quot;,j,a[j],p,q); &#125; if((i-1)%2==0)&#123;x0=p;y0=q;&#125;//如果I是奇数，X0与Y0都是0 else&#123;x0=2*p*p+1;y0=2*p*q;&#125;//如果I是偶数，X0是两倍P方+1，y0是两倍PQ return true;&#125;int main()&#123; ll n,x,y; while(~scanf(&quot;%lld&quot;,&amp;n))&#123; if(pell_minimum_solution(n,x,y))&#123;//输入N求X,Y的值，有解就输出 printf(&quot;x=%lld y=%lld\t&quot;,x,y);//x,y printf(&quot;%lld^2-%lld*%lld^2=1\t&quot;,x,n,y);//x^2-n*y^2=1 printf(&quot;%lld-%lld=1\n&quot;,x*x,n*y*y);//(x^2)-(n*y^2)=1 &#125; &#125; return 0;&#125; 暴力法1234567891011121314typedef long long ll;int x,y;void mysearch()&#123; y=1; while(1)&#123; x=(ll)sqrt(d*y*y+1); if(x*x-d*y*y==1)&#123; break; &#125; y++; &#125;&#125; 快速幂1234567int power(int a,int b,int P)&#123; int re=1; for(;b;b&gt;&gt;=1,a=(long long)a*a%P) if(b&amp;1) re=(long long)re*a%P; return re;&#125; exgcd12345678910111213141516171819#include &lt;cstdio&gt;using namespace std;int a,b,c,d,x,y;void exgcd(int a,int b,int &amp;d,int &amp;x,int &amp;y)&#123; if(!b) d=a,x=1,y=0; else exgcd(b,a%b,d,y,x),y-=a/b*x;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); exgcd(a,b,d,x,y); if(!(c%d)) &#123; x*=c/d;y*=c/d;a/=d;b/=d; for(int k=-2;k&lt;=2;k++) printf(&quot;%d %d\n&quot;,x+k*b,y-k*a); &#125;&#125; BM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1000000007;ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;ll _,n;namespace linear_seq&#123; const int N=10010; ll res[N],base[N],_c[N],_md[N]; vector&lt;ll&gt; Md; void mul(ll *a,ll *b,int k) &#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; &#125; int solve(ll n,VI a,VI b) &#123; ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt;p&gt;=0;p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (int i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans; &#125; VI BM(VI s) &#123; VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; int gao(VI a,ll n)&#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c))); &#125;&#125;;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld&quot;,&amp;n); vector&lt;int&gt;v; v.push_back(1); //至少8项，越多越好。 v.push_back(5); v.push_back(15); v.push_back(35); v.push_back(70); v.push_back(126); v.push_back(210); v.push_back(330); v.push_back(495); v.push_back(715); printf(&quot;%lld\n&quot;,linear_seq::gao(v,n-1)%mod); &#125;&#125; 组合数学计算数学凸包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;const int N=1e5+5;const double eps=1e-6;int n,top;double len,S;struct Point &#123; double x,y; &#125; a[N],b[N];double dis(Point x,Point y)&#123; return sqrt((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y));&#125;double Cross(Point x,Point y,Point z)&#123; return (x.x-z.x)*(y.y-z.y)-(x.y-z.y)*(y.x-z.x);&#125;double Cross(Point x,Point y)&#123; return x.x*y.y-x.y*y.x;&#125;bool cmp(const Point &amp;x,const Point &amp;y)&#123; double t=Cross(x,y,a[1]);return abs(t)&gt;eps?t&gt;0:dis(a[1],x)&lt;dis(a[1],y);&#125;inline void Graham()&#123; int t=1; for(int i=2;i&lt;=n;i++) if(a[i].x&lt;a[t].x||(a[i].x==a[t].x&amp;&amp;a[i].y&lt;a[t].y)) t=i; if(t!=1) std::swap(a[t],a[1]); std::sort(a+2,a+n+1,cmp); for(int i=1;i&lt;=n;i++) &#123; while(top&gt;1&amp;&amp;Cross(a[i],b[top],b[top-1])&gt;=0) top--; b[++top]=a[i]; &#125; b[top+1]=b[1];&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;a[i].x,&amp;a[i].y); Graham();//求凸包的点 for(int i=1;i&lt;=top;i++) len+=dis(b[i],b[i+1]); printf(&quot;L: %.8lf\n&quot;,len);//求凸包的长度 for(int i=1;i&lt;=top;i++) S+=Cross(b[i],b[i+1]); printf(&quot;S: %.8lf\n&quot;,S/2);//求凸包的面积 &#125; 点旋转123假设对图片上任意点(x,y)，绕一个坐标点(rx0,ry0)逆时针旋转a角度后的新的坐标设为(x0, y0)，有公式： x0= (x - rx0)*cos(a) - (y - ry0)*sin(a) + rx0 ; y0= (x - rx0)*sin(a) + (y - ry0)*cos(a) + ry0 ; 图论最短路Floyd算法，多源无负权12345678910111213141516//通过邻接矩阵跑出所有点之间的最短路,时间复杂度O(n^3),空间复杂度O(n^2)//d[i][j]表示i到j的最短路径长度,初始化：d[i][i]=0,点到点有路按正常权值初始化,其余INFint mp[n][n];int d[n][n];void Floyd()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) d[i][j]=mp[i][j]; for(int k=1;k&lt;=n;k++) //枚举以k为中间点的所有点的最短路 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);&#125; Dijkstra算法,单源无负权12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//适用于边权为正的情况,单源最短路问题//时间复杂度为O(V*V+E)//算法思路:设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，//第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，//以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了）//不断的维护一个dis数组，最后得到的dis数组中dis[i]就是源点到图中节点i的最短路径的长度//记录vis数组判断当前点是否访问过int mp[n][n];int dis[n];int vis[n];void init()&#123; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(i==j) mp[i][j]=0; else mp[i][j]=INF; &#125; &#125;&#125;int djs(int st,int ed)&#123; for(int i=1;i&lt;=n;i++) &#123; dis[i]=mp[st][i]; vis[i]=0; &#125; vis[st]=1; for(int i=1;i&lt;n;i++) //更新dis数组,起点不用更新了,所以是n-1次 &#123; int minn=INF; //更新最小距离点 int next=-1; //确定下一个点 for(int j=1;j&lt;=n;j++) &#123; if(vis[j]==0&amp;&amp;dis[j]&lt;minn) &#123; minn=dis[j]; next=j; &#125; &#125; if(next==-1) //当前已不存在点 continue; vis[next]=1; for(int j=1;j&lt;=n;j++) &#123; if(vis[j]==0) //vis[j]=1已为最短路径 dis[j]=min(dis[j],dis[next]+mp[next][j]); //以next为中间点进行松弛 &#125; &#125; return dis[ed]; //找到st到ed的最短路&#125; SPFA,Bellman-Ford的队列优化,玄学时间复杂度,O(E)-O(VE)之间123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//假设有一个点刚刚被优化了，我们可以很明显的发现，针对这条边，//也就只有这条边的出边上的终点才可以继续被优化，这就给了我们启示，//其实我们可以再维护一个队列，一个点如果被优化过了，那么就进队列，int mp[n][n];int n,m;int dis[n];int vis[n];void init()&#123; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(i==j) mp[i][j]=0; else mp[i][j]=INF; &#125; &#125;&#125;int spfa(int st,int ed)&#123; for(int i=1;i&lt;=n;i++) &#123; dis[i]=INF; vis[i]=0; &#125; dis[st]=0; queue&lt;int&gt;q; q.push(st); vis[st]=1; while(!q.empty()) &#123; int now=q.front(); q.pop(); vis[now]=0; for(int i=1;i&lt;=n;i++) &#123; if(dis[i]&gt;dis[now]+mp[now][i]) &#123; dis[i]=dis[now]+mp[now][i]; if(vis[i]==0) &#123; q.push(i); vis[i]=1; &#125; &#125; &#125; &#125; return dis[ed];&#125; 并查集1234567891011121314151617181920212223242526272829303132333435int par[MAX_N]; //父亲 int rank[MAX_N]; //树的高度//初始化n个元素void init(int n)&#123; for(int i = 0; i &lt; n; i++)&#123; par[i] = i; rank[i] = 0; &#125;&#125; //查询树的根int find(int x)&#123; if(par[x] == x) return x; else return par[x] = find(par[x]);&#125; //合并x和y所属的集合void unite(int x, int y)&#123; x = find(x); y = find(y); if(x == y) return; if(rank[x] &lt; rank[y]) par[x] = y; else par[y] = x; if(rank[x] == rank[y]) rank[x]++;&#125; //判断x和y是否属于同一个集合bool same(int x, int y)&#123; return find(x) == find(y);&#125;]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kunagbin专题一 kmp]]></title>
    <url>%2F2019%2F01%2F26%2Fkunagbin%E4%B8%93%E9%A2%98%E4%B8%80-kmp%2F</url>
    <content type="text"><![CDATA[A B C D E F G H I J K L M N O P √ √ √ √ √ √ √ √ √ √ A - Oulipo简单kmp板子题，求母串里有几个子串 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[1000001];long long int sum;char a[1000001],b[1000001];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j];//j取-1只是为了判断边界，就如果j为0的话会一直循环下去 next[i+1]=j+1;//匹配到第i+1个时，从第i个开始匹配，例如abcabcd 与 abcabce第3个匹配不上，但是前两个匹配得上 &#125;&#125;void KMP()&#123; for(int i=0,j=0;i&lt;n;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=b[j]) j=next[j]; if(j==m-1) sum++; &#125;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; sum=0; memset(next,0,sizeof(next)); scanf(&quot;%s%s&quot;,b,a); //a-&gt;long b-&gt;short n=strlen(a);m=strlen(b); Getnext(); KMP(); printf(&quot;%lld\n&quot;,sum); &#125; return 0;&#125; B - Number Sequence子字符串在母串的位置，板子题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[1000001];long long int sum;int a[1000001],b[1000001];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j];//j取-1只是为了判断边界，就如果j为0的话会一直循环下去 next[i+1]=j+1;//匹配到第i+1个时，从第i个开始匹配，例如abcabcd 与 abcabce第3个匹配不上，但是前两个匹配得上 &#125;&#125;void KMP()&#123; for(int i=0,j=0;i&lt;n;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=b[j]) j=next[j]; if(j==m-1) &#123; sum=i-j+1; return; &#125; &#125;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; sum=0; int i; memset(next,0,sizeof(next)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(i=0;i&lt;m;i++) &#123; scanf(&quot;%d&quot;,&amp;b[i]); &#125; Getnext(); KMP(); if(sum==0) sum=-1; printf(&quot;%lld\n&quot;,sum); &#125; return 0;&#125; C - Period当前位循环节的个数，也是板子题，next数组的应用 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[1000001];long long int sum;char b[1000001];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j]; next[i+1]=j+1; &#125;&#125;int main()&#123; int t,i; for(t=1;;t++) &#123; memset(next,0,sizeof(next)); scanf(&quot;%d&quot;,&amp;m); if(m==0) break; scanf(&quot;%s&quot;,b); printf(&quot;Test case #%d\n&quot;,t); Getnext(); for(i=1;i&lt;=m;i++) &#123; if(next[i]&gt;0) &#123; if(i%(i-next[i])==0) &#123; printf(&quot;%d %d\n&quot;,i,i/(i-next[i])); &#125; &#125; &#125; printf(&quot;\n&quot;); &#125; return 0;&#125; D - Power Strings和c差不多，仍然是求循环节的个数。 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[1000001];long long int sum;char b[1000001];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j]; next[i+1]=j+1; &#125;&#125;int main()&#123; while(1) &#123; int i; memset(next,0,sizeof(next)); scanf(&quot;%s&quot;,b); m=strlen(b); if(b[0]==&apos;.&apos;&amp;&amp;m==1) break; Getnext(); if(m%(m-next[m])==0) &#123; printf(&quot;%d\n&quot;,m/(m-next[m])); &#125; else &#123; printf(&quot;1\n&quot;); &#125; &#125; return 0;&#125; E - Count the string子串在母串的个数和，还是偏板子的思维题。 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[1000001];int men[1000001];long long int sum;char b[1000001];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j]; next[i+1]=j+1; &#125;&#125;int main()&#123; int t,i; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; sum=0; scanf(&quot;%d&quot;,&amp;m); scanf(&quot;%s&quot;,b); Getnext(); for(i=1;i&lt;=m;i++) &#123; //printf(&quot;%d &quot;,next[i]); if(next[i]&gt;0) sum++; &#125; printf(&quot;%lld\n&quot;,(sum+m)%10007); &#125; return 0;&#125; F - Cyclic Nacklace在后面添加几个可以让当前字符串构成循环，注意最后一位。next数组的利用。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;string.h&gt;int next[100005],m;char b[100005];void getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(b[i]!=b[j]&amp;&amp;j!=-1) j=next[j]; next[i+1]=j+1; &#125; return;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; memset(next,0,sizeof(next)); scanf(&quot;%s&quot;,b); m=strlen(b); getnext(); if(m%(m-next[m])==0&amp;&amp;next[m]!=0) &#123; printf(&quot;0\n&quot;); &#125; else &#123; int men=m-next[m]; int j=next[m]%men; printf(&quot;%d\n&quot;,men-j); &#125; &#125; return 0; &#125; G - Simpsons’ Hidden Talents最长前后缀,kmp一次就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;string.h&gt;int next[1000005],m,n,sum;char b[1000005],a[1000005];void getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(b[i]!=b[j]&amp;&amp;j!=-1) j=next[j]; next[i+1]=j+1; &#125; return;&#125;void KMP()&#123; for(int i=0,j=0;i&lt;n;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=b[j]) j=next[j]; sum=j; &#125;&#125;int main()&#123; while(scanf(&quot;%s%s&quot;,b,a)!=EOF) &#123; sum=0; memset(next,0,sizeof(next)); n=strlen(a); m=strlen(b); getnext(); KMP(); for(int i=0;i&lt;=sum;i++) printf(&quot;%c&quot;,b[i]); if(sum&gt;-1) printf(&quot; %d\n&quot;,sum+1); else &#123; printf(&quot;%d\n&quot;,sum+1); &#125; &#125; return 0; &#125; H - Milking Grid求最小覆盖问题，就横竖两次遍历的next数组的应用，然后求他们循环节的最大公倍数，注意，不能超过m,n。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;char a[10005][100];long long int next[10005];int main()&#123; long long int qum=1,sum=1; long long int i,j,m,n; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; scanf(&quot; %c&quot;,&amp;a[i][j]); &#125; &#125; for(i=0;i&lt;n;i++) &#123; memset(next,0,sizeof(next)); next[0]=-1; for(int ii=1,j=0;ii&lt;m;ii++,j++) &#123; while(a[i][ii]!=a[i][j]&amp;&amp;j!=-1) j=next[j]; next[ii+1]=j+1; &#125; sum=((sum/__gcd(sum,(m-next[m])))*((m-next[m]))); if(sum&gt;m) sum=m; &#125; for(i=0;i&lt;m;i++) &#123; memset(next,0,sizeof(next)); next[0]=-1; for(int ii=1,j=0;ii&lt;n;ii++,j++) &#123; while(a[ii][i]!=a[j][i]&amp;&amp;j!=-1) j=next[j]; next[ii+1]=j+1; &#125; qum=((qum/__gcd(qum,(n-next[n])))*(n-next[n])); if(qum&gt;n) qum=n; &#125; printf(&quot;%lld\n&quot;,sum*qum); return 0; &#125; I - Theme Section使输入的字符串满足EAEBE格式的最长E串，next数组的利用，我们可以认为最长为n=next[m]（该字符串的前后缀长度）E（AEB）E，然后从头到尾找是否还有子串满足前后缀长度为n,即找满足EAE格式。如果找不到n–，一直到找到或者n为0 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;string.h&gt;int next[1000005];char a[1000005];int m;void Getnext()&#123; int i,j; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=a[j]) j=next[j]; next[i+1]=j+1; &#125; return;&#125;int main()&#123; int i,j,n,t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%s&quot;,a); m=strlen(a); Getnext(); n=next[m]; for(i=n;i&gt;=0;i--) &#123; for(j=1;j&lt;=m;j++) &#123; if(next[j]==i) break; &#125; if(j&lt;m) &#123; break; &#125; &#125; printf(&quot;%d\n&quot;,i); &#125; return 0;&#125; M - Substring Frequency板子题，子串在母串出现了几次。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;string.h&gt;int next[1000005];char a[1000005];int m;void Getnext()&#123; int i,j; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=a[j]) j=next[j]; next[i+1]=j+1; &#125; return;&#125;int main()&#123; int i,j,n,t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%s&quot;,a); m=strlen(a); Getnext(); n=next[m]; for(i=n;i&gt;=0;i--) &#123; for(j=1;j&lt;=m;j++) &#123; if(next[j]==i) break; &#125; if(j&lt;m) &#123; break; &#125; &#125; printf(&quot;%d\n&quot;,i); &#125; return 0;&#125;]]></content>
      <categories>
        <category>VJ</category>
      </categories>
      <tags>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
