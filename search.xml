<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[弱水三千只取一瓢饮]]></title>
    <url>%2F2029%2F02%2F03%2F%E5%BC%B1%E6%B0%B4%E4%B8%89%E5%8D%83%E5%8F%AA%E5%8F%96%E4%B8%80%E7%93%A2%E9%A5%AE%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019 fjut校赛 J(kmp|exkmp|ntt)]]></title>
    <url>%2F2019%2F05%2F13%2F2019-fjut%E6%A0%A1%E8%B5%9B-J-kmp-exkmp-ntt%2F</url>
    <content type="text"><![CDATA[链接第六集，想不到你这个浓眉大眼的都叛变革命了 题意给你一个母串和子串，如果子串改变一个字符能匹配母串，则输出yes，否者输出no 题解方法很多，大佬用的ntt和exkmp，菜鸡的我用的kmp，对母串每个位置分别求个前缀最长能匹配的子串位置，然后存下来，然后对它跑后缀，查在它前面两个的位置匹配的前缀的位置，如果前缀加后缀和加1（容错的1个）等于m（子串长度），则ok，后面就是细节了，因为匹配是最长，可能会出现循环节多了的情况，比如abcabc我们匹配到了abcabc,但是只需要abc，所以长度还得减去循环节，查看是否相等，还有如果匹配长度等于m-1并且后面还有字符则一定也可以，并且如果完全匹配也可以 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;string.h&gt;#include&lt;stdio.h&gt;int flag;int n,m,next[1000005],next2[1000005];char a[1000005],b[1000005];char aa[1000005],bb[1000005];int ab[1000005];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j]; next[i+1]=j+1; &#125;&#125;void Getnext2()&#123; next2[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;bb[i]!=bb[j]) j=next2[j]; next2[i+1]=j+1; &#125;&#125;void KMP()&#123; for(int i=0,j=0;i&lt;n;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=b[j]) j=next[j]; ab[i]=j; if(j+2==m&amp;&amp;i&lt;n-1||(j==-1&amp;&amp;j+2==m&amp;&amp;i&lt;n)) &#123; flag=1; &#125; if(j==m-1) flag=1; &#125;&#125;void KMP2()&#123; for(int i=0,j=0;i&lt;n;i++,j++) &#123; while(j!=-1&amp;&amp;aa[i]!=bb[j]) j=next2[j]; if(ab[n-i-3]+j+3==m&amp;&amp;n&gt;=i+3) &#123; flag=1; &#125; else if(ab[n-i-3]+j+3&gt;m&amp;&amp;n&gt;=i+3) &#123; if((ab[n-i-3]+1)%(ab[n-i-3]+1-next[ab[n-i-3]+1])==0&amp;&amp;(ab[n-i-3]+j+3-m)%((ab[n-i-3]+1-next[ab[n-i-3]+1]))==0) &#123; flag=1; &#125; if((j+1)%(j+1-next2[j+1])==0&amp;&amp;(ab[n-i-3]+j+3-m)%(j+1-next2[j+1])==0) &#123; flag=1; &#125; &#125; if(j+2==m&amp;&amp;i&lt;n-1||(j==-1&amp;&amp;j+2==m&amp;&amp;i&lt;n)) &#123; flag=1; &#125; &#125;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; flag=0; scanf(&quot;%s%s&quot;,a,b); //a-&gt;long b-&gt;short n=strlen(a);m=strlen(b); //if(m==1) //flag=1; Getnext(); KMP(); for(int i=0;i&lt;n;i++) &#123; aa[i]=a[n-i-1]; &#125; for(int i=0;i&lt;m;i++) &#123; bb[i]=b[m-i-1]; &#125; Getnext2(); KMP2(); if(m&gt;n) flag=0; if(flag==1) printf(&quot;YES\n&quot;); else printf(&quot;NO\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>fjut</category>
      </categories>
      <tags>
        <tag>-kmp -exkmp -ntt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 4110 Strings in the Pocket (马拉车求回文串数量）]]></title>
    <url>%2F2019%2F04%2F29%2FZOJ-4110-Strings-in-the-Pocket-%E9%A9%AC%E6%8B%89%E8%BD%A6%E6%B1%82%E5%9B%9E%E6%96%87%E4%B8%B2%E6%95%B0%E9%87%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链接K- Strings in the Pocket 题意给你两个字符串ab，可以对a串中的子串进行翻转，问有多少对lr使得翻转后的a串等于b串 题解如果a串等于b串，则就是求a串中的回文串的数目（串的数目可能很多，得开longlong ）如果不一样，一定翻转第一个不相等和最后一个不相等的位置，然后判断翻转后是否相等，然后两边看能不能加特判l==r 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;char a[2000005],b[2000005],s_new[5000005];int p[5000005]; int init()&#123; int len=strlen(a),j=2; s_new[0]=&apos;$&apos;,s_new[1]=&apos;#&apos;; for(int i=0;i&lt;len;i++)&#123; s_new[j++]=a[i]; s_new[j++]=&apos;#&apos;; &#125; s_new[j]=0; return j;&#125;long long int manacher()&#123; long long int res=0; int len=init(),mx=0,id; for(int i=0;i&lt;len;i++)&#123; if(mx&gt;i)p[i]=min(p[2*id-i],mx-i); else p[i]=1; while(s_new[i-p[i]]==s_new[i+p[i]])p[i]++; if(mx&lt;i+p[i])mx=i+p[i],id=i; res+=p[i]/2; &#125; return res;&#125;int main()&#123; int i,j,m,n; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot; %s %s&quot;,a,b); n=strlen(a); int flag=-1,maxx=0; for(i=0;i&lt;n;i++) &#123; if(a[i]!=b[i]&amp;&amp;flag==-1) &#123; flag=i; &#125; if(a[i]!=b[i]) &#123; maxx=i; &#125; &#125; if(flag==-1) &#123; long long int cnt=manacher();//除以2是因为这里的字符串之间插入了‘#’ printf(&quot;%lld\n&quot;,cnt); &#125; else &#123; int cnt=1,jj; for(j=flag-1,jj=maxx+1;j&gt;=0,jj&lt;n;j--,jj++) &#123; if(a[j]!=a[jj]||j&lt;0||jj&gt;=n) break; else cnt++; &#125; if(maxx==flag) cnt=0; else &#123; int k; for(j=flag,k=maxx;j&lt;=maxx;j++,k--) &#123; if(a[j]!=b[k]) break; &#125; if(j&lt;=maxx) cnt=0; &#125; printf(&quot;%d\n&quot;,cnt); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>zoj</category>
      </categories>
      <tags>
        <tag>Manacher</tag>
        <tag>浙江省省赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sort的使用]]></title>
    <url>%2F2019%2F01%2F31%2Fsort%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[C++ 中sort 函数及 cmp 自定义规则的使用需要用到的头文件12#include&lt;algorithm&gt;using namespace std; 需要传两到三个参数，数据类型不限，只要是内定义了大小比较符，我们可以只传两个参数（区间首地址，区间尾地址的下一个地址）例如sort(a,a+n),对从a[0]到a[n-1]的数据进行从小到大的排序，如果想要改变排序方式或者对内部未定义大小比较符的进行排序，我们需要再传个比较函数cmp进去。，例如：12345678bool cmp(node x,node y)&#123; if(x.a!=y.a) return x.a if(x.b!=y.b) return x.b&gt;y.b; return return x.c&gt;y.c;&#125; sort(arr,arr+n,cmp); 先按a值升序排列，如果a值相同，再按b值降序排列，如果b还相同，就按c降序排列。]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Palindrome (Manacher)]]></title>
    <url>%2F2019%2F01%2F30%2FPalindrome-Manacher%2F</url>
    <content type="text"><![CDATA[链接A - Palindrome 题意输出最长的子回文串的长度 题解马拉车模板题 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int Manacher(string s) &#123; // Insert &apos;#&apos; string t = &quot;$#&quot;; for (int i = 0; i &lt; s.size(); ++i) &#123; t += s[i]; t += &quot;#&quot;; &#125; // Process t vector&lt;int&gt; p(t.size(), 0); int mx = 0, id = 0, resLen = 0, resCenter = 0; for (int i = 1; i &lt; t.size(); ++i) &#123; p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1; while (t[i + p[i]] == t[i - p[i]]) ++p[i]; if (mx &lt; i + p[i]) &#123; mx = i + p[i]; id = i; &#125; if (resLen &lt; p[i]) &#123; resLen = p[i]; resCenter = i; &#125; &#125; return resLen - 1;&#125;int main() &#123; string s1; int k=0; while(1) &#123; k++; cin&gt;&gt;s1; if(s1[0]==&apos;E&apos;) break; else &#123; cout&lt;&lt;&quot;Case &quot;&lt;&lt;k&lt;&lt;&quot;: &quot;&lt;&lt;Manacher(s1)&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>VJ</category>
      </categories>
      <tags>
        <tag>VJ</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[E1. Array and Segments(暴力)]]></title>
    <url>%2F2019%2F01%2F28%2FE1-Array-and-Segments-%E6%9A%B4%E5%8A%9B-1%2F</url>
    <content type="text"><![CDATA[链接E1. Array and Segments (Easy version) 题意一串长为n的数串，m个区间，选择区间使得该区间的数减一，求最后修改完后数串(max-min)的最大值。 题解方法很多，e1是简单，直接暴力即可，对每一位都当做最大值来进行区间选择，我们知道如果使得（max-min)的值最大，则max越大，min越小越好，由于没有加的操作，所以我们只能间接让max最大，即当选定为max后，如果区间包含该位置则不选该区间，如果不包含，则选区间，因为他可能有两种情况，使min更小或者不影响结果。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;int a[1000005];int b[1000005];int l[1000005];int r[1000005];int main()&#123; int i,j,m,n,k,sum=0,minn=1000000,memi=1,memn=0,qum; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(i=1;i&lt;=m;i++) &#123; scanf(&quot;%d%d&quot;,&amp;l[i],&amp;r[i]); &#125; for(i=1;i&lt;=n;i++) &#123; qum=0; for(j=1;j&lt;=n;j++) b[j]=a[j]; for(j=1;j&lt;=m;j++) &#123; if(l[j]&lt;=i&amp;&amp;r[j]&gt;=i) &#123; &#125; else &#123; qum++; for(k=l[j];k&lt;=r[j];k++) b[k]--; &#125; &#125; minn=b[1]; for(j=2;j&lt;=n;j++) &#123; if(b[j]&lt;minn) minn=b[j]; &#125; if(sum&lt;a[i]-minn) &#123; memn=qum; memi=i; sum=a[i]-minn; &#125; &#125; printf(&quot;%d\n&quot;,sum); printf(&quot;%d\n&quot;,memn); int dum=0; for(i=1;i&lt;=m;i++) &#123; if(l[i]&lt;=memi&amp;&amp;r[i]&gt;=memi) &#123; &#125; else &#123; dum++; if(dum==memn) printf(&quot;%d\n&quot;,i); else printf(&quot;%d &quot;,i); &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[D. Game with modulo(交互，二分)]]></title>
    <url>%2F2019%2F01%2F28%2FD-Game-with-modulo-%E4%BA%A4%E4%BA%92%EF%BC%8C%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[链接D. Game with modulo 题意给你一个a，你可以输入x,y进行询问，返回”x”, 如果 (x mod a)≥(y mod a)，返回”y”,如果(x mod a)&lt;(y mod a)，最多60次询问，请设计一个方案求出a的值。 题解分块二分，首先0到1询问，如果返回为x则证明a为1，然后询问（1，2）（2，4）（4，8）……（1e9,2e9)，如果返回为x则证明a在该区间，对区间进行二分查询。 最开始想的是直接1到2e9进行二分，发现会超过60次。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;long long int a[50],l,r,m;char f[100];int main()&#123; int i,j,n; a[0]=0; a[1]=1; for(i=2;i&lt;=32;i++) &#123; a[i]=a[i-1]*2; &#125; while(scanf(&quot; %s&quot;,f)!=EOF) &#123; if(f[0]!=&apos;s&apos;) break; char c; for(i=0;i&lt;=30;i++) &#123; printf(&quot;? %lld %lld\n&quot;,a[i],a[i+1]); fflush(stdout); scanf(&quot; %c&quot;,&amp;c); if(c==&apos;x&apos;) break; &#125; if(a[i]==0) &#123; printf(&quot;! 1\n&quot;); fflush(stdout); &#125; else &#123; l=a[i]+1,r=a[i+1]; while(l&lt;r) &#123; m=(l+r)/2; printf(&quot;? %lld %lld\n&quot;,m,l-1); fflush(stdout); scanf(&quot; %c&quot;,&amp;c); if(c==&apos;x&apos;) l=m+1; else r=m; &#125; printf(&quot;! %lld\n&quot;,l); fflush(stdout); &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>二分</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[acm模板]]></title>
    <url>%2F2019%2F01%2F27%2Facm%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[其他位运算1234567891011121314151617#include&lt;iostream&gt;using namespace std;int main()&#123; int n=15,m=8;//1111，1000 unsigned int x=8,y=7; cout&lt;&lt;__builtin_popcount(n)&lt;&lt;endl;//判断n中有几个1 cout&lt;&lt;__builtin_parity(n)&lt;&lt;endl;//判断n中1的个数的奇偶性,奇数输出1，偶数输出0 cout&lt;&lt;__builtin_parity(m)&lt;&lt;endl; cout&lt;&lt;__builtin_ffs(n)&lt;&lt;endl;//判断n的二进制末尾最后一个1的位置 cout&lt;&lt;__builtin_ffs(m)&lt;&lt;endl; cout&lt;&lt;__builtin_ctzll(n)&lt;&lt;endl;//判断n的二进制末尾后面0的个数，当n为0时，和n的类型有关 cout&lt;&lt;__builtin_ctz(m)&lt;&lt;endl; cout&lt;&lt;__builtin_clz(x)&lt;&lt;endl;//前导0的个数(为32位） cout&lt;&lt;__builtin_clz(y)&lt;&lt;endl; return 0; &#125; 博弈nim博弈123456789101112131415//读入n，表示有从物品数分别1到n的n堆物品，假设n个数存在数组f[]中，当n很大的时候异或和 int xor_n(int n)//从1到n的异或和&#123; int t = n &amp; 3; if (t &amp; 1) return t / 2 ^ 1; return t / 2 ^ n;&#125;int Nim_Game(int n)//有必胜策略返回1，nim博弈 &#123; int flag=0; for(int i=1;i&lt;=n;i++) flag^=xor_n(f[i]); if(flag) return 1; return 0;&#125; sg函数sg(x)=sg(mem(y));y为x的后继，例如x的后继为a,b,c，那么SG(x)=mex{SG(a),SG(b),SG(c)}，当sg(x)==0时,代表当前点为必败.对于多种状态，sg（x)=sg(x1)^sg(x2)^….; sg打表1234567891011121314151617181920212223//f[]：可以取走的石子个数//sg[]:0~n的SG函数值//hash[]:mex&#123;&#125;int f[N],sg[N],hash[N]; void getSG(int n)&#123; int i,j; memset(sg,0,sizeof(sg)); for(i=1;i&lt;=n;i++) &#123; memset(hash,0,sizeof(hash)); for(j=1;f[j]&lt;=i;j++) hash[sg[i-f[j]]]=1;//标记，f[j]表示能够取的，i-f[i]表示他的后继 for(j=0;j&lt;=n;j++) //求mes&#123;&#125;中未出现的最小的非负整数 &#123; if(hash[j]==0) &#123; sg[i]=j; break; &#125; &#125; &#125;&#125; dfs123456789101112131415161718192021222324252627//注意 S数组要按从小到大排序 SG函数要初始化为-1 对于每个集合只需初始化1遍//n是集合s的大小 S[i]是定义的特殊取法规则的数组int s[110],sg[10010],n;int SG_dfs(int x)&#123; int i; if(sg[x]!=-1) return sg[x]; bool vis[110]; memset(vis,0,sizeof(vis)); for(i=0;i&lt;n;i++) &#123; if(x&gt;=s[i]) &#123; SG_dfs(x-s[i]); vis[sg[x-s[i]]]=1; &#125; &#125; int e; for(i=0;;i++) if(!vis[i]) &#123; e=i; break; &#125; return sg[x]=e;&#125; 数据结构线段树线段树的单点修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const int maxn=1e6+5;int a[maxn]; //存每个数的值struct node&#123; int sum; int ll,rr;&#125;tree[maxn*4];void Pushup(int id) //区间合并&#123; tree[id].sum=tree[id*2].sum+tree[id*2+1].sum;&#125;void Pushdown() //区间下放，进行区间修改的时候用到&#123;&#125;void Build(int id,int ll,int rr) //建树&#123; tree[id].ll=ll; tree[id].rr=rr; if(ll==rr) &#123; tree[id].sum=a[ll]; return; &#125; int mid=(ll+rr)/2; //mid=ll+rr&gt;&gt;1; Build(id*2,ll,mid); Build(id*2+1,mid+1,rr); //Build(id&lt;&lt;1,ll,mid); //Build(id&lt;&lt;1|1,mid+1,rr); Pushup(id);&#125;void Update(int id,int x,int y) //修改&#123; if(tree[id].ll==tree[id].rr) &#123; tree[id].sum=y; return; &#125; int mid=(tree[id].ll+tree[id].rr)/2; if(x&lt;=mid) Update(id*2,x,y); else Update(id*2+1,x,y); Pushup(id);&#125;int Query(int id,int x,int y) //查询&#123; if(x&lt;=tree[id].ll&amp;&amp;tree[id].rr&lt;=y)//到头的情况 return tree[id].sum; int mid=(tree[id].ll+tree[id].rr)/2; if(y&lt;=mid) //只需要访问左边 return Query(id*2,x,y); else if(x&gt;=mid+1) return Query(id*2+1,x,y); else return Query(id*2,x,y)+Query(id*2+1,x,y);&#125; 线段树的区间修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const int maxn=1e6+5;long long int a[maxn];long long int lazy[maxn*4]; //存每个数的值struct node&#123; long long int sum; long long int ll,rr;&#125;tree[maxn*4];void Pushup(int id) //区间合并&#123; tree[id].sum=tree[id*2].sum+tree[id*2+1].sum;&#125;void Pushdown(int id) //区间下放，进行区间修改的时候用到&#123; if(lazy[id]) &#123; tree[id*2].sum+=lazy[id]*(tree[id*2].rr-tree[id*2].ll+1); tree[id*2+1].sum+=lazy[id]*(tree[id*2+1].rr-tree[id*2+1].ll+1); lazy[id*2]+=lazy[id]; lazy[id*2+1]+=lazy[id]; lazy[id]=0; &#125;&#125;void Build(int id,int ll,int rr) //建树&#123; lazy[id]=0; tree[id].ll=ll; tree[id].rr=rr; if(ll==rr) &#123; tree[id].sum=a[ll]; return; &#125; int mid=(ll+rr)/2; //mid=ll+rr&gt;&gt;1; //Build(ltree); //Build(rtree); Build(id&lt;&lt;1,ll,mid); Build(id&lt;&lt;1|1,mid+1,rr); Pushup(id);&#125;void Update(int id,int x,int y,int z) //修改&#123; if(x&lt;=tree[id].ll&amp;&amp;tree[id].rr&lt;=y) &#123; tree[id].sum+=z*(tree[id].rr-tree[id].ll+1); lazy[id]+=z; return; &#125; int mid=(tree[id].ll+tree[id].rr)/2; Pushdown(id); if(y&lt;=mid) Update(id*2,x,y,z); else if(x&gt;=mid+1) Update(id*2+1,x,y,z); else &#123; Update(id*2,x,y,z); Update(id*2+1,x,y,z); &#125; Pushup(id);&#125;long long int Query(int id,int x,int y) //查询&#123; if(x&lt;=tree[id].ll&amp;&amp;tree[id].rr&lt;=y)//到头的情况 return tree[id].sum; int mid=(tree[id].ll+tree[id].rr)/2; Pushdown(id); if(y&lt;=mid) //只需要访问左边 return Query(id*2,x,y); else if(x&gt;=mid+1) return Query(id*2+1,x,y); else return Query(id*2,x,y)+Query(id*2+1,x,y);&#125; 主席树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100000 + 5;int a[N], b[N], rt[N * 20], ls[N * 20], rs[N * 20], sum[N * 20];int n, k, tot, sz, ql, qr, x, q, T;void Build(int&amp; o, int l, int r)&#123; o = ++ tot; sum[o] = 0; if(l == r) return; int m = (l + r) &gt;&gt; 1; Build(ls[o], l, m); Build(rs[o], m + 1, r);&#125;void update(int&amp; o, int l, int r, int last, int p)&#123; o = ++ tot; ls[o] = ls[last]; rs[o] = rs[last]; sum[o] = sum[last] + 1; if(l == r) return; int m = (l + r) &gt;&gt; 1; if(p &lt;= m) update(ls[o], l, m, ls[last], p); else update(rs[o], m + 1, r, rs[last], p);&#125;int query(int ss, int tt, int l, int r, int k)&#123; if(l == r) return l; int m = (l + r) &gt;&gt; 1; int cnt = sum[ls[tt]] - sum[ls[ss]]; if(k &lt;= cnt) return query(ls[ss], ls[tt], l, m, k); else return query(rs[ss], rs[tt], m + 1, r, k - cnt);&#125;void work()&#123; scanf(&quot;%d%d%d&quot;, &amp;ql, &amp;qr, &amp;x); int ans = query(rt[ql - 1], rt[qr], 1, sz, x); printf(&quot;%d\n&quot;, b[ans]);&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;T); while(T--)&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, a + i), b[i] = a[i]; sort(b + 1, b + n + 1); sz = unique(b + 1, b + n + 1) - (b + 1); tot = 0; Build(rt[0],1, sz); //for(int i = 0; i &lt;= 4 * n; i ++)printf(&quot;%d,rt = %d,ls = %d, rs = %d, sum = %d\n&quot;, i, rt[i], ls[i], rs[i], sum[i]); for(int i = 1; i &lt;= n; i ++)a[i] = lower_bound(b + 1, b + sz + 1, a[i]) - b; for(int i = 1; i &lt;= n; i ++)update(rt[i], 1, sz, rt[i - 1], a[i]); //for(int i = 0; i &lt;= 5 * n; i ++)printf(&quot;%d,rt = %d,ls = %d, rs = %d, sum = %d\n&quot;, i, rt[i], ls[i], rs[i], sum[i]); while(q --)work(); &#125; return 0;&#125; 树状数组123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;int tree[1000000],n;int lowbit(int x)&#123; return x&amp;(-x);&#125;int Query(int x)//查询x项的前缀和 ； &#123; int res=0; while(x) &#123; res+=tree[x]; x-=lowbit(x); &#125; return res;&#125;void Add(int x,int v)//在x位加v； &#123; while(x&lt;=n) &#123; tree[x]+=v; x+=lowbit(x); &#125;&#125;int main()&#123; int a[100000],x; scanf(&quot;%d %d&quot;,&amp;n,&amp;x); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++) &#123; Add(i,a[i]);//树状数组的预处理，初始化 &#125; printf(&quot;%d\n&quot;,Query(x)); return 0;&#125; st表1234567891011121314void Init()&#123; for(int i = 0; i &lt; n; i++) d[i][0] = a[i]; for(int j = 1; (1&lt;&lt;j) &lt;= n; j++) for(int i = 0; i+(1&lt;&lt;j) &lt;= n; i++) d[i][j] = min(d[i][j-1], d[i+(1&lt;&lt;(j-1))][j-1]);&#125;int RMQ(int l, int r)&#123; int k = 0; while((1&lt;&lt;k) &lt;= r-l+1)k++; k--; return min(d[l][k], d[r-(1&lt;&lt;k)+1][k]);&#125; 字符串倍增求后缀数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//LCP(i,j)为suff(sa[i])与suff(sa[j])的最长公共前缀,LCP(i,k)=min(height[j]) 对于任意1&lt;i&lt;=j&lt;=k&lt;=n 相同的子串数目为height数组和（二分字符串长度）//x[i]为第i个元素的第一关键字，y[i]为第二关键字排名为i的数第一关键字的位置,rk[i]就表示起始位置的下标为i的后缀的排名,sa[i]表示排名为i的后缀的起始位置的下标，height[i]为LCP(i,i-1)#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define rint register int#define inv inline void#define ini inline int#define maxn 1000050using namespace std;char s[maxn];int y[maxn],x[maxn],c[maxn],sa[maxn],rk[maxn],height[maxn],wt[30];int n,m;inv get_SA() &#123; for (rint i=1; i&lt;=n; ++i) ++c[x[i]=s[i]];//赋值再加，相当于x[i]=s[i],++c[x[i]] for (rint i=2; i&lt;=m; ++i) c[i]+=c[i-1]; for (rint i=n; i&gt;=1; --i) sa[c[x[i]]--]=i;//排名 for (rint k=1; k&lt;=n; k&lt;&lt;=1) &#123; rint num=0; for (rint i=n-k+1; i&lt;=n; ++i) y[++num]=i;//第n-k+1到第n位是没有第二关键字的 所以排名在最前面 for (rint i=1; i&lt;=n; ++i) if (sa[i]&gt;k) y[++num]=sa[i]-k; for (rint i=1; i&lt;=m; ++i) c[i]=0; for (rint i=1; i&lt;=n; ++i) ++c[x[i]]; for (rint i=2; i&lt;=m; ++i) c[i]+=c[i-1]; //第一关键字排名为1~i的数有多少个 for (rint i=n; i&gt;=1; --i) sa[c[x[y[i]]]--]=y[i],y[i]=0;//基数排序 swap(x,y); x[sa[1]]=1; num=1; for (rint i=2; i&lt;=n; ++i) x[sa[i]]=(y[sa[i]]==y[sa[i-1]] &amp;&amp; y[sa[i]+k]==y[sa[i-1]+k]) ? num : ++num; if (num==n) break; m=num; &#125; for (rint i=1; i&lt;=n; ++i) printf(&quot;%d &quot;,sa[i]);&#125;inv get_height() &#123; rint k=0; for (rint i=1; i&lt;=n; ++i) rk[sa[i]]=i; for (rint i=1; i&lt;=n; ++i) &#123; if (rk[i]==1) continue;//第一名height为0 if (k) --k;//h[i]&gt;=h[i-1]-1; rint j=sa[rk[i]-1]; while (j+k&lt;=n &amp;&amp; i+k&lt;=n &amp;&amp; s[i+k]==s[j+k]) ++k; height[rk[i]]=k;//h[i]=height[rk[i]]; &#125; printf(&quot;\n&quot;); for (rint i=1; i&lt;=n; ++i) printf(&quot;%d &quot;,height[i]);&#125;int main() &#123; gets(s+1); n=strlen(s+1); m=122;//n表示原字符串长度，m表示字符个数，ascll(&apos;z&apos;)=122 get_SA(); get_height();&#125; 倍增lcp1234567891011121314151617181920212223242526272829303132333435#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;const int base=29;int n,sa[10001];char s[10001];unsigned long long ha[10001],power[10001]=&#123;1&#125;;unsigned long long HASH(int l,int r)&#123; return ha[r]-ha[l-1]*power[r-l+1];&#125;int LCP(int x,int y)&#123; int l=0,r=std::min(n-x+1,n-y+1),mid; while(l&lt;r) &#123; mid=(l+r+1)&gt;&gt;1; if(HASH(x,x+mid-1)==HASH(y,y+mid-1)) l=mid; else r=mid-1; &#125; return l;&#125;bool cmp(int x,int y)&#123; int z=LCP(x,y);return s[x+z]&lt;s[y+z];&#125;int main()&#123; scanf(&quot;%s&quot;,s+1); n=strlen(s+1); for(int i=1;i&lt;=n;i++) ha[i]=ha[i-1]*base+s[i]-&apos;a&apos;+1,power[i]=power[i-1]*base,sa[i]=i; std::sort(sa+1,sa+n+1,cmp); for(int i=2;i&lt;=n;i++) height[i]=LCP(sa[i-1],sa[i]);&#125; 回文树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const int MAXN = 100005 ; const int N = 26 ; struct Palindromic_Tree &#123; int next[MAXN][N] ;//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成 int fail[MAXN] ;//fail指针，失配后跳转到fail指针指向的节点 int cnt[MAXN] ; //当前节点表示的回文串在原串中出现了多少次(建树时求出的不是完全的，最后count()函数跑一遍以后才是正确的） int num[MAXN] ; //表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数 int len[MAXN] ;//len[i]表示节点i表示的回文串的长度（一个节点表示一个回文串） int S[MAXN];//存放添加的字符 int last ;//指向新添加一个字母后所形成的最长回文串表示的节点 int n ;//表示添加的字符个数 int p ;//表示添加的节点个数 int newnode ( int l ) &#123;//新建节点 for ( int i = 0 ; i &lt; N ; ++ i ) next[p][i] = 0 ; cnt[p] = 0 ; num[p] = 0 ; len[p] = l ; return p ++ ; &#125; void init () &#123;//初始化 p = 0 ; newnode ( 0 ) ; newnode ( -1 ) ; last = 0 ; n = 0 ; S[n] = -1 ;//开头放一个字符集中没有的字符，减少特判 fail[0] = 1 ; &#125; int get_fail ( int x ) &#123;//和KMP一样，失配后找一个尽量最长的 while ( S[n - len[x] - 1] != S[n] ) x = fail[x] ; return x ; &#125; void add ( int c ) &#123; c -= &apos;a&apos; ; S[++n] = c ; int cur = get_fail ( last ) ;//通过上一个回文串找这个回文串的匹配位置 if ( !next[cur][c] ) &#123;//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串 int now = newnode ( len[cur] + 2 ) ;//新建节点 fail[now] = next[get_fail ( fail[cur] )][c] ;//和AC自动机一样建立fail指针，以便失配后跳转 next[cur][c] = now ; num[now] = num[fail[now]] + 1 ; &#125; last = next[cur][c] ; cnt[last] ++ ; &#125; void count () &#123; for ( int i = p - 1 ; i &gt;= 0 ; -- i ) cnt[fail[i]] += cnt[i] ; //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！ &#125; &#125;run; int main()&#123; scanf(&quot;%s&quot;,&amp;S); run.init(); nn=strlen(S)-1; fo(int i=0,i&lt;=nn,i++)run.add(S[i],i); run.count();&#125; 字典树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;stdio.h&gt; #include&lt;string.h&gt;#define N 1000struct Node&#123; int sum;//前缀 int next[26];//子节点 void init()&#123; sum=0; memset(next,-1,sizeof next); &#125;&#125;tire[N];int tot;void insert(char *str)&#123; int len=strlen(str); int root=0; for(int i=0;i&lt;len;i++)&#123; int x=str[i]-&apos;a&apos;; if(tire[root].next[x]==-1) tire[root].next[x]=tot++; root=tire[root].next[x]; tire[root].sum++; &#125;&#125;int search(char *str)&#123; int len=strlen(str); int root=0; for(int i=0;i&lt;len;i++)&#123; int x=str[i]-&apos;a&apos;; if(tire[root].next[x]==-1) return 0; root=tire[root].next[x]; &#125; return tire[root].sum;&#125;void del(char *str,int word)&#123; int len=strlen(str); int root=0; if(word&lt;0) return; for(int i=0;i&lt;len;i++)&#123; int x=str[i]-&apos;a&apos;; if(tire[root].next[x]==-1) return; tire[root].sum-=word; root=tire[root].next[x]; &#125; tire[root].sum=0; for(int i=0;i&lt;26;i++) tire[root].next[i]=-1;&#125;int main()&#123; tot=1; for(int i=0;i&lt;N;i++) tire[i].init(); int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; char str[10],word[35]; scanf(&quot;%s%s&quot;,str,word); if(str[0]==&apos;i&apos;)//插入 insert(word); else if(str[0]==&apos;d&apos;)//删除 del(word,search(word)); else&#123;//查询 if(search(word)&gt;0) printf(&quot;Yes\n&quot;,search(word)); else printf(&quot;No\n&quot;); &#125; &#125; return 0;&#125; 01字符串123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int tol; //节点个数 LL val[32*MAXN]; //点的值 int ch[32*MAXN][2]; //边的值 void init()&#123; //初始化 tol=1; ch[0][0]=ch[0][1]=0;&#125;void insert(LL x)&#123; //往 01字典树中插入 x int u=0; for(int i=32;i&gt;=0;i--) &#123; int v=(x&gt;&gt;i)&amp;1; if(!ch[u][v]) &#123; //如果节点未被访问过 ch[tol][0]=ch[tol][1]=0; //将当前节点的边值初始化 val[tol]=0; //节点值为0，表示到此不是一个数 ch[u][v]=tol++; //边指向的节点编号 &#125; u=ch[u][v]; //下一节点 &#125; val[u]=x; //节点值为 x，即到此是一个数 &#125;void update(LL x,int add)&#123; //更新插入或删除 x后每个节点被访问的次数（1为加，-1为减） int u=0; for(int i=32;i&gt;=0;i--) &#123; int v=(x&gt;&gt;i)&amp;1; u=ch[u][v]; num[u]+=add; &#125;&#125;LL query(LL x)&#123; //查询所有数中和 x异或结果最大的数 int u=0; for(int i=32;i&gt;=0;i--) &#123; int v=(x&gt;&gt;i)&amp;1; //利用贪心策略，优先寻找和当前位不同的数 if(ch[u][v^1]) u=ch[u][v^1]; else u=ch[u][v]; &#125; return val[u]; //返回结果 &#125; 最小最大表示法字符串通过翻转使得字典序最小（最大）例如abc可以翻转成bca,cab.1234567891011121314151617181920int Get_min() &#123; int n = strlen(s); int i = 0,j = 1,k = 0,t; //表示从i开始k长度和从j开始k长度的字符串相同 while(i &lt; n &amp;&amp; j &lt; n &amp;&amp; k &lt; n) &#123; t = s[(i+k)%n] - s[(j+k)%n]; //t用来计算相对应位置上那个字典序较大 if(!t) k++;//字符相等的情况 else &#123; if(t &gt; 0) i += k+1;//i位置大,最大表示法: j += k+1 else j += k+1;//j位置大,最大表示法: i += k+1 if(i == j) j++; k = 0; &#125; &#125; return i &gt;j ?j :i;&#125; kmp12345678910111213141516171819202122232425262728#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[100001];char a[100001],b[100001];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j]; next[i+1]=j+1; &#125;&#125;void KMP()&#123; for(int i=0,j=0;i&lt;n;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=b[j]) j=next[j]; if(j==m-1) printf(&quot;%d\n&quot;,i-j+1); &#125;&#125;int main()&#123; scanf(&quot;%s%s&quot;,a,b); //a-&gt;long b-&gt;short n=strlen(a);m=strlen(b); Getnext(); KMP();&#125; ac自动机12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;const int N=500005;int T,n,tot,end[N],fail[N],son[N][26];char s[N*2];std::queue&lt;int&gt; Q;void init(int x)&#123; end[x]=0; for(int i=0;i&lt;26;i++) son[x][i]=0;&#125;void Add()&#123; scanf(&quot;%s&quot;,s); int len=strlen(s),pre=0; for(int i=0;i&lt;len;i++) &#123; if(!son[pre][s[i]-&apos;a&apos;]) init(son[pre][s[i]-&apos;a&apos;]=++tot); pre=son[pre][s[i]-&apos;a&apos;]; &#125; end[pre]++;&#125;void Build()&#123; Q.push(0); while(!Q.empty()) &#123; int x=Q.front();Q.pop(); for(int i=0;i&lt;26;i++) &#123; if(son[x][i]) &#123; Q.push(son[x][i]); fail[son[x][i]]=x?son[fail[x]][i]:0; &#125; else son[x][i]=x?son[fail[x]][i]:0; &#125; &#125;&#125;int Calc()&#123; scanf(&quot;%s&quot;,s); int len=strlen(s),pre=0,ans=0; for(int i=0;i&lt;len;i++) &#123; pre=son[pre][s[i]-&apos;a&apos;]; for(int j=pre;j;j=fail[j]) ans+=end[j],end[j]=0; &#125; return ans;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; init(tot=0); for(scanf(&quot;%d&quot;,&amp;n);n;n--) Add(); Build(); printf(&quot;%d\n&quot;,Calc()); &#125;&#125; Manacher推荐博客：Manacher’s Algorithm 马拉车算法1234567891011121314151617181920212223242526272829303132333435363738#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string Manacher(string s) &#123; // Insert &apos;#&apos; string t = &quot;$#&quot;;//在头插入$# for (int i = 0; i &lt; s.size(); ++i) &#123; t += s[i]; t += &quot;#&quot;;//s[i]的每个字母前后都插入# &#125; // Process t vector&lt;int&gt; p(t.size(), 0); int mx = 0, id = 0, resLen = 0, resCenter = 0; for (int i = 1; i &lt; t.size(); ++i) &#123;//两个指针mx,resLen，两个保存变量id,resCenter; resLen代表最长的回文串中心的半径，i代表最长的回文串 p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1;//p[i]存以该点为中心，回文串的半径（包含该点）(例$#1#2#2#1)最中间的#半径为4 //2*id-i是i关于id的对称点，如果mx-i&gt;p[j]，则为12321，id为3，mx为3，i为4，j为2，p[j]=1,p[i]也应该为1，i，j在id包围中且j的回文串也在id的包围中，所以i的回文串应该和j一样 //如果mx-i&lt;p[j]，也就是超出了id的包含范围，这个时候p[i]只能为mx-i，剩下的只能一个一个的匹配了 while (t[i + p[i]] == t[i - p[i]]) ++p[i];//回文串处理 if (mx &lt; i + p[i]) &#123; mx = i + p[i];//mx是回文串所能到达的最右边的位置 id = i; &#125; if (resLen &lt; p[i]) &#123; resLen = p[i]; resCenter = i; &#125; &#125; return s.substr((resCenter - resLen) / 2, resLen - 1);//返回最大的回文串，(resCenter - resLen) / 2为开始位置 ， resLen - 1为长度（包含了#） &#125;int main() &#123; string s1 = &quot;12212&quot;; cout &lt;&lt; Manacher(s1) &lt;&lt; endl; string s2 = &quot;122122&quot;; cout &lt;&lt; Manacher(s2) &lt;&lt; endl; string s = &quot;waabwswfd&quot;; cout &lt;&lt; Manacher(s) &lt;&lt; endl;&#125; 数学公式abs((x2-x1)(y3-y1)-(x3-x1)(y2-y1)) 计算几何三维几何123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293//三维几何函数库#include &lt;math.h&gt;#define eps 1e-8#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)struct point3&#123;double x,y,z;&#125;;struct line3&#123;point3 a,b;&#125;;struct plane3&#123;point3 a,b,c;&#125;;//三点决定一个平面 //计算cross product U x V 叉乘 point3 xmult(point3 u,point3 v)&#123; point3 ret; ret.x=u.y*v.z-v.y*u.z; ret.y=u.z*v.x-u.x*v.z; ret.z=u.x*v.y-u.y*v.x; return ret;&#125;//计算dot product U . V 点积 double dmult(point3 u,point3 v)&#123; return u.x*v.x+u.y*v.y+u.z*v.z;&#125;//矢量差 U - Vpoint3 subt(point3 u,point3 v)&#123; point3 ret; ret.x=u.x-v.x; ret.y=u.y-v.y; ret.z=u.z-v.z; return ret;&#125;//取平面法向量point3 pvec(plane3 s)&#123; return xmult(subt(s.a,s.b),subt(s.b,s.c));&#125;point3 pvec(point3 s1,point3 s2,point3 s3)&#123; return xmult(subt(s1,s2),subt(s2,s3));&#125;//两点距离,单参数取向量大小double distance(point3 p1,point3 p2)&#123; return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y)+(p1.z-p2.z)*(p1.z-p2.z));&#125;//向量大小double vlen(point3 p)&#123; return sqrt(p.x*p.x+p.y*p.y+p.z*p.z);&#125;//判三点共线int dots_inline(point3 p1,point3 p2,point3 p3)&#123; return vlen(xmult(subt(p1,p2),subt(p2,p3)))&lt;eps;&#125;//判四点共面int dots_onplane(point3 a,point3 b,point3 c,point3 d)&#123; return zero(dmult(pvec(a,b,c),subt(d,a)));&#125;//判点是否在线段上,包括端点和共线int dot_online_in(point3 p,line3 l)&#123; return zero(vlen(xmult(subt(p,l.a),subt(p,l.b))))&amp;&amp;(l.a.x-p.x)*(l.b.x-p.x)&lt;eps&amp;&amp; (l.a.y-p.y)*(l.b.y-p.y)&lt;eps&amp;&amp;(l.a.z-p.z)*(l.b.z-p.z)&lt;eps;&#125;int dot_online_in(point3 p,point3 l1,point3 l2)&#123; return zero(vlen(xmult(subt(p,l1),subt(p,l2))))&amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps&amp;&amp; (l1.y-p.y)*(l2.y-p.y)&lt;eps&amp;&amp;(l1.z-p.z)*(l2.z-p.z)&lt;eps;&#125;//判点是否在线段上,不包括端点int dot_online_ex(point3 p,line3 l)&#123; return dot_online_in(p,l)&amp;&amp;(!zero(p.x-l.a.x)||!zero(p.y-l.a.y)||!zero(p.z-l.a.z))&amp;&amp; (!zero(p.x-l.b.x)||!zero(p.y-l.b.y)||!zero(p.z-l.b.z));&#125;int dot_online_ex(point3 p,point3 l1,point3 l2)&#123; return dot_online_in(p,l1,l2)&amp;&amp;(!zero(p.x-l1.x)||!zero(p.y-l1.y)||!zero(p.z-l1.z))&amp;&amp; (!zero(p.x-l2.x)||!zero(p.y-l2.y)||!zero(p.z-l2.z));&#125;//判点是否在空间三角形上,包括边界,三点共线无意义int dot_inplane_in(point3 p,plane3 s)&#123; return zero(vlen(xmult(subt(s.a,s.b),subt(s.a,s.c)))-vlen(xmult(subt(p,s.a),subt(p,s.b)))- vlen(xmult(subt(p,s.b),subt(p,s.c)))-vlen(xmult(subt(p,s.c),subt(p,s.a))));&#125;int dot_inplane_in(point3 p,point3 s1,point3 s2,point3 s3)&#123; return zero(vlen(xmult(subt(s1,s2),subt(s1,s3)))-vlen(xmult(subt(p,s1),subt(p,s2)))- vlen(xmult(subt(p,s2),subt(p,s3)))-vlen(xmult(subt(p,s3),subt(p,s1))));&#125;//判点是否在空间三角形上,不包括边界,三点共线无意义int dot_inplane_ex(point3 p,plane3 s)&#123; return dot_inplane_in(p,s)&amp;&amp;vlen(xmult(subt(p,s.a),subt(p,s.b)))&gt;eps&amp;&amp; vlen(xmult(subt(p,s.b),subt(p,s.c)))&gt;eps&amp;&amp;vlen(xmult(subt(p,s.c),subt(p,s.a)))&gt;eps;&#125;int dot_inplane_ex(point3 p,point3 s1,point3 s2,point3 s3)&#123; return dot_inplane_in(p,s1,s2,s3)&amp;&amp;vlen(xmult(subt(p,s1),subt(p,s2)))&gt;eps&amp;&amp; vlen(xmult(subt(p,s2),subt(p,s3)))&gt;eps&amp;&amp;vlen(xmult(subt(p,s3),subt(p,s1)))&gt;eps;&#125;//判两点在线段同侧,点在线段上返回0,不共面无意义int same_side(point3 p1,point3 p2,line3 l)&#123; return dmult(xmult(subt(l.a,l.b),subt(p1,l.b)),xmult(subt(l.a,l.b),subt(p2,l.b)))&gt;eps;&#125;int same_side(point3 p1,point3 p2,point3 l1,point3 l2)&#123; return dmult(xmult(subt(l1,l2),subt(p1,l2)),xmult(subt(l1,l2),subt(p2,l2)))&gt;eps;&#125;//判两点在线段异侧,点在线段上返回0,不共面无意义int opposite_side(point3 p1,point3 p2,line3 l)&#123; return dmult(xmult(subt(l.a,l.b),subt(p1,l.b)),xmult(subt(l.a,l.b),subt(p2,l.b)))&lt;-eps;&#125;int opposite_side(point3 p1,point3 p2,point3 l1,point3 l2)&#123; return dmult(xmult(subt(l1,l2),subt(p1,l2)),xmult(subt(l1,l2),subt(p2,l2)))&lt;-eps;&#125;//判两点在平面同侧,点在平面上返回0int same_side(point3 p1,point3 p2,plane3 s)&#123; return dmult(pvec(s),subt(p1,s.a))*dmult(pvec(s),subt(p2,s.a))&gt;eps;&#125;int same_side(point3 p1,point3 p2,point3 s1,point3 s2,point3 s3)&#123; return dmult(pvec(s1,s2,s3),subt(p1,s1))*dmult(pvec(s1,s2,s3),subt(p2,s1))&gt;eps;&#125;//判两点在平面异侧,点在平面上返回0int opposite_side(point3 p1,point3 p2,plane3 s)&#123; return dmult(pvec(s),subt(p1,s.a))*dmult(pvec(s),subt(p2,s.a))&lt;-eps;&#125;int opposite_side(point3 p1,point3 p2,point3 s1,point3 s2,point3 s3)&#123; return dmult(pvec(s1,s2,s3),subt(p1,s1))*dmult(pvec(s1,s2,s3),subt(p2,s1))&lt;-eps;&#125;//判两直线平行int parallel(line3 u,line3 v)&#123; return vlen(xmult(subt(u.a,u.b),subt(v.a,v.b)))&lt;eps;&#125;int parallel(point3 u1,point3 u2,point3 v1,point3 v2)&#123; return vlen(xmult(subt(u1,u2),subt(v1,v2)))&lt;eps;&#125;//判两平面平行int parallel(plane3 u,plane3 v)&#123; return vlen(xmult(pvec(u),pvec(v)))&lt;eps;&#125;int parallel(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3)&#123; return vlen(xmult(pvec(u1,u2,u3),pvec(v1,v2,v3)))&lt;eps;&#125;//判直线与平面平行int parallel(line3 l,plane3 s)&#123; return zero(dmult(subt(l.a,l.b),pvec(s)));&#125;int parallel(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123; return zero(dmult(subt(l1,l2),pvec(s1,s2,s3)));&#125;//判两直线垂直int perpendicular(line3 u,line3 v)&#123; return zero(dmult(subt(u.a,u.b),subt(v.a,v.b)));&#125;int perpendicular(point3 u1,point3 u2,point3 v1,point3 v2)&#123; return zero(dmult(subt(u1,u2),subt(v1,v2)));&#125;//判两平面垂直int perpendicular(plane3 u,plane3 v)&#123; return zero(dmult(pvec(u),pvec(v)));&#125;int perpendicular(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3)&#123; return zero(dmult(pvec(u1,u2,u3),pvec(v1,v2,v3)));&#125;//判直线与平面平行int perpendicular(line3 l,plane3 s)&#123; return vlen(xmult(subt(l.a,l.b),pvec(s)))&lt;eps;&#125;int perpendicular(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123; return vlen(xmult(subt(l1,l2),pvec(s1,s2,s3)))&lt;eps;&#125;//判两线段相交,包括端点和部分重合int intersect_in(line3 u,line3 v)&#123; if (!dots_onplane(u.a,u.b,v.a,v.b)) return 0; if (!dots_inline(u.a,u.b,v.a)||!dots_inline(u.a,u.b,v.b)) return !same_side(u.a,u.b,v)&amp;&amp;!same_side(v.a,v.b,u); return dot_online_in(u.a,v)||dot_online_in(u.b,v)||dot_online_in(v.a,u)||dot_online_in(v.b,u);&#125;int intersect_in(point3 u1,point3 u2,point3 v1,point3 v2)&#123; if (!dots_onplane(u1,u2,v1,v2)) return 0; if (!dots_inline(u1,u2,v1)||!dots_inline(u1,u2,v2)) return !same_side(u1,u2,v1,v2)&amp;&amp;!same_side(v1,v2,u1,u2); return dot_online_in(u1,v1,v2)||dot_online_in(u2,v1,v2)||dot_online_in(v1,u1,u2)||dot_online_in(v2,u1,u2);&#125;//判两线段相交,不包括端点和部分重合int intersect_ex(line3 u,line3 v)&#123; return dots_onplane(u.a,u.b,v.a,v.b)&amp;&amp;opposite_side(u.a,u.b,v)&amp;&amp;opposite_side(v.a,v.b,u);&#125;int intersect_ex(point3 u1,point3 u2,point3 v1,point3 v2)&#123; return dots_onplane(u1,u2,v1,v2)&amp;&amp;opposite_side(u1,u2,v1,v2)&amp;&amp;opposite_side(v1,v2,u1,u2);&#125;//判线段与空间三角形相交,包括交于边界和(部分)包含int intersect_in(line3 l,plane3 s)&#123; return !same_side(l.a,l.b,s)&amp;&amp;!same_side(s.a,s.b,l.a,l.b,s.c)&amp;&amp; !same_side(s.b,s.c,l.a,l.b,s.a)&amp;&amp;!same_side(s.c,s.a,l.a,l.b,s.b);&#125;int intersect_in(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123; return !same_side(l1,l2,s1,s2,s3)&amp;&amp;!same_side(s1,s2,l1,l2,s3)&amp;&amp; !same_side(s2,s3,l1,l2,s1)&amp;&amp;!same_side(s3,s1,l1,l2,s2);&#125;//判线段与空间三角形相交,不包括交于边界和(部分)包含int intersect_ex(line3 l,plane3 s)&#123; return opposite_side(l.a,l.b,s)&amp;&amp;opposite_side(s.a,s.b,l.a,l.b,s.c)&amp;&amp; opposite_side(s.b,s.c,l.a,l.b,s.a)&amp;&amp;opposite_side(s.c,s.a,l.a,l.b,s.b);&#125;int intersect_ex(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123; return opposite_side(l1,l2,s1,s2,s3)&amp;&amp;opposite_side(s1,s2,l1,l2,s3)&amp;&amp; opposite_side(s2,s3,l1,l2,s1)&amp;&amp;opposite_side(s3,s1,l1,l2,s2);&#125;//计算两直线交点,注意事先判断直线是否共面和平行!//线段交点请另外判线段相交(同时还是要判断是否平行!)point3 intersection(line3 u,line3 v)&#123; point3 ret=u.a; double t=((u.a.x-v.a.x)*(v.a.y-v.b.y)-(u.a.y-v.a.y)*(v.a.x-v.b.x)) /((u.a.x-u.b.x)*(v.a.y-v.b.y)-(u.a.y-u.b.y)*(v.a.x-v.b.x)); ret.x+=(u.b.x-u.a.x)*t; ret.y+=(u.b.y-u.a.y)*t; ret.z+=(u.b.z-u.a.z)*t; return ret;&#125;point3 intersection(point3 u1,point3 u2,point3 v1,point3 v2)&#123; point3 ret=u1; double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x)) /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x)); ret.x+=(u2.x-u1.x)*t; ret.y+=(u2.y-u1.y)*t; ret.z+=(u2.z-u1.z)*t; return ret;&#125;//计算直线与平面交点,注意事先判断是否平行,并保证三点不共线!//线段和空间三角形交点请另外判断point3 intersection(line3 l,plane3 s)&#123; point3 ret=pvec(s); double t=(ret.x*(s.a.x-l.a.x)+ret.y*(s.a.y-l.a.y)+ret.z*(s.a.z-l.a.z))/ (ret.x*(l.b.x-l.a.x)+ret.y*(l.b.y-l.a.y)+ret.z*(l.b.z-l.a.z)); ret.x=l.a.x+(l.b.x-l.a.x)*t; ret.y=l.a.y+(l.b.y-l.a.y)*t; ret.z=l.a.z+(l.b.z-l.a.z)*t; return ret;&#125;point3 intersection(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123; point3 ret=pvec(s1,s2,s3); double t=(ret.x*(s1.x-l1.x)+ret.y*(s1.y-l1.y)+ret.z*(s1.z-l1.z))/ (ret.x*(l2.x-l1.x)+ret.y*(l2.y-l1.y)+ret.z*(l2.z-l1.z)); ret.x=l1.x+(l2.x-l1.x)*t; ret.y=l1.y+(l2.y-l1.y)*t; ret.z=l1.z+(l2.z-l1.z)*t; return ret;&#125;//计算两平面交线,注意事先判断是否平行,并保证三点不共线!line3 intersection(plane3 u,plane3 v)&#123; line3 ret; ret.a=parallel(v.a,v.b,u.a,u.b,u.c)?intersection(v.b,v.c,u.a,u.b,u.c):intersection(v.a,v.b,u.a,u.b,u.c); ret.b=parallel(v.c,v.a,u.a,u.b,u.c)?intersection(v.b,v.c,u.a,u.b,u.c):intersection(v.c,v.a,u.a,u.b,u.c); return ret;&#125;line3 intersection(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3)&#123; line3 ret; ret.a=parallel(v1,v2,u1,u2,u3)?intersection(v2,v3,u1,u2,u3):intersection(v1,v2,u1,u2,u3); ret.b=parallel(v3,v1,u1,u2,u3)?intersection(v2,v3,u1,u2,u3):intersection(v3,v1,u1,u2,u3); return ret;&#125;//点到直线距离double ptoline(point3 p,line3 l)&#123; return vlen(xmult(subt(p,l.a),subt(l.b,l.a)))/distance(l.a,l.b);&#125;double ptoline(point3 p,point3 l1,point3 l2)&#123; return vlen(xmult(subt(p,l1),subt(l2,l1)))/distance(l1,l2);&#125;//点到平面距离double ptoplane(point3 p,plane3 s)&#123; return fabs(dmult(pvec(s),subt(p,s.a)))/vlen(pvec(s));&#125;double ptoplane(point3 p,point3 s1,point3 s2,point3 s3)&#123; return fabs(dmult(pvec(s1,s2,s3),subt(p,s1)))/vlen(pvec(s1,s2,s3));&#125;//直线到直线距离double linetoline(line3 u,line3 v)&#123; point3 n=xmult(subt(u.a,u.b),subt(v.a,v.b)); return fabs(dmult(subt(u.a,v.a),n))/vlen(n);&#125;double linetoline(point3 u1,point3 u2,point3 v1,point3 v2)&#123; point3 n=xmult(subt(u1,u2),subt(v1,v2)); return fabs(dmult(subt(u1,v1),n))/vlen(n);&#125;//两直线夹角cos值double angle_cos(line3 u,line3 v)&#123; return dmult(subt(u.a,u.b),subt(v.a,v.b))/vlen(subt(u.a,u.b))/vlen(subt(v.a,v.b));&#125;double angle_cos(point3 u1,point3 u2,point3 v1,point3 v2)&#123; return dmult(subt(u1,u2),subt(v1,v2))/vlen(subt(u1,u2))/vlen(subt(v1,v2));&#125;//两平面夹角cos值double angle_cos(plane3 u,plane3 v)&#123; return dmult(pvec(u),pvec(v))/vlen(pvec(u))/vlen(pvec(v));&#125;double angle_cos(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3)&#123; return dmult(pvec(u1,u2,u3),pvec(v1,v2,v3))/vlen(pvec(u1,u2,u3))/vlen(pvec(v1,v2,v3));&#125;//直线平面夹角sin值double angle_sin(line3 l,plane3 s)&#123; return dmult(subt(l.a,l.b),pvec(s))/vlen(subt(l.a,l.b))/vlen(pvec(s));&#125;double angle_sin(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123; return dmult(subt(l1,l2),pvec(s1,s2,s3))/vlen(subt(l1,l2))/vlen(pvec(s1,s2,s3));&#125; ####圆1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;math.h&gt;#define eps 1e-8struct point&#123;double x,y;&#125;;double xmult(point p1,point p2,point p0)&#123; return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125;double distance(point p1,point p2)&#123; return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));&#125;double disptoline(point p,point l1,point l2)&#123; return fabs(xmult(p,l1,l2))/distance(l1,l2);&#125;point intersection(point u1,point u2,point v1,point v2)&#123; point ret=u1; double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x)) /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x)); ret.x+=(u2.x-u1.x)*t; ret.y+=(u2.y-u1.y)*t; return ret;&#125;//判直线和圆相交,包括相切int intersect_line_circle(point c,double r,point l1,point l2)&#123; return disptoline(c,l1,l2)&lt;r+eps;&#125;//判线段和圆相交,包括端点和相切int intersect_seg_circle(point c,double r,point l1,point l2)&#123; double t1=distance(c,l1)-r,t2=distance(c,l2)-r; point t=c; if (t1&lt;eps||t2&lt;eps) return t1&gt;-eps||t2&gt;-eps; t.x+=l1.y-l2.y; t.y+=l2.x-l1.x; return xmult(l1,c,t)*xmult(l2,c,t)&lt;eps&amp;&amp;disptoline(c,l1,l2)-r&lt;eps;&#125;//判圆和圆相交,包括相切int intersect_circle_circle(point c1,double r1,point c2,double r2)&#123; return distance(c1,c2)&lt;r1+r2+eps&amp;&amp;distance(c1,c2)&gt;fabs(r1-r2)-eps;&#125;//计算圆上到点p最近点,如p与圆心重合,返回p本身point dot_to_circle(point c,double r,point p)&#123; point u,v; if (distance(p,c)&lt;eps) return p; u.x=c.x+r*fabs(c.x-p.x)/distance(c,p); u.y=c.y+r*fabs(c.y-p.y)/distance(c,p)*((c.x-p.x)*(c.y-p.y)&lt;0?-1:1); v.x=c.x-r*fabs(c.x-p.x)/distance(c,p); v.y=c.y-r*fabs(c.y-p.y)/distance(c,p)*((c.x-p.x)*(c.y-p.y)&lt;0?-1:1); return distance(u,p)&lt;distance(v,p)?u:v;&#125;//计算直线与圆的交点,保证直线与圆有交点//计算线段与圆的交点可用这个函数后判点是否在线段上void intersection_line_circle(point c,double r,point l1,point l2,point&amp; p1,point&amp; p2)&#123; point p=c; double t; p.x+=l1.y-l2.y; p.y+=l2.x-l1.x; p=intersection(p,c,l1,l2); t=sqrt(r*r-distance(p,c)*distance(p,c))/distance(l1,l2); p1.x=p.x+(l2.x-l1.x)*t; p1.y=p.y+(l2.y-l1.y)*t; p2.x=p.x-(l2.x-l1.x)*t; p2.y=p.y-(l2.y-l1.y)*t;&#125;//计算圆与圆的交点,保证圆与圆有交点,圆心不重合void intersection_circle_circle(point c1,double r1,point c2,double r2,point&amp; p1,point&amp; p2)&#123; point u,v; double t; t=(1+(r1*r1-r2*r2)/distance(c1,c2)/distance(c1,c2))/2; u.x=c1.x+(c2.x-c1.x)*t; u.y=c1.y+(c2.y-c1.y)*t; v.x=u.x+c1.y-c2.y; v.y=u.y-c1.x+c2.x; intersection_line_circle(c1,r1,u,v,p1,p2);&#125;//将向量p逆时针旋转angle角度Point Rotate(Point p,double angle) &#123; Point res; res.x=p.x*cos(angle)-p.y*sin(angle); res.y=p.x*sin(angle)+p.y*cos(angle); return res;&#125;//求圆外一个点与圆(o,r)的两个切点result1和result2void TangentPoint_PC(Point poi,Point o,double r,Point &amp;result1,Point &amp;result2) &#123; double line=sqrt((poi.x-o.x)*(poi.x-o.x)+(poi.y-o.y)*(poi.y-o.y)); double angle=acos(r/line); Point unitvector,lin; lin.x=poi.x-o.x; lin.y=poi.y-o.y; unitvector.x=lin.x/sqrt(lin.x*lin.x+lin.y*lin.y)*r; unitvector.y=lin.y/sqrt(lin.x*lin.x+lin.y*lin.y)*r; result1=Rotate(unitvector,-angle); result2=Rotate(unitvector,angle); result1.x+=o.x; result1.y+=o.y; result2.x+=o.x; result2.y+=o.y; return;&#125; 多边形123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include&lt;stdio.h&gt;#define MAXN 1000#define offset 10000#define eps 1e-8#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)#define _sign(x) ((x)&gt;eps?1:((x)&lt;-eps?2:0))struct point&#123;double x,y;&#125;;struct line&#123;point a,b;&#125;;//叉乘 double xmult(point p1,point p2,point p0)&#123; return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125; //判定凸多边形,顶点按顺时针或逆时针给出,允许相邻边共线int is_convex(int n,point* p)&#123; int i,s[3]=&#123;1,1,1&#125;; for (i=0;i&lt;n&amp;&amp;s[1]|s[2];i++) s[_sign(xmult(p[(i+1)%n],p[(i+2)%n],p[i]))]=0; return s[1]|s[2];&#125;//判定凸多边形,顶点按顺时针或逆时针给出,不允许相邻边共线int is_convex_v2(int n,point* p)&#123; int i,s[3]=&#123;1,1,1&#125;; for (i=0;i&lt;n&amp;&amp;s[0]&amp;&amp;s[1]|s[2];i++) s[_sign(xmult(p[(i+1)%n],p[(i+2)%n],p[i]))]=0; return s[0]&amp;&amp;s[1]|s[2];&#125;//判点在凸多边形内或多边形边上,顶点按顺时针或逆时针给出int inside_convex(point q,int n,point* p)&#123; int i,s[3]=&#123;1,1,1&#125;; for (i=0;i&lt;n&amp;&amp;s[1]|s[2];i++) s[_sign(xmult(p[(i+1)%n],q,p[i]))]=0; return s[1]|s[2];&#125;//判点在凸多边形内,顶点按顺时针或逆时针给出,在多边形边上返回0int inside_convex_v2(point q,int n,point* p)&#123; int i,s[3]=&#123;1,1,1&#125;; for (i=0;i&lt;n&amp;&amp;s[0]&amp;&amp;s[1]|s[2];i++) s[_sign(xmult(p[(i+1)%n],q,p[i]))]=0; return s[0]&amp;&amp;s[1]|s[2];&#125;/*//判点在任意多边形内,顶点按顺时针或逆时针给出//on_edge表示点在多边形边上时的返回值,offset为多边形坐标上限int inside_polygon(point q,int n,point* p,int on_edge=1)&#123; point q2; int i=0,count; while (i&lt;n) for (count=i=0,q2.x=rand()+offset,q2.y=rand()+offset;i&lt;n;i++) if (zero(xmult(q,p[i],p[(i+1)%n]))&amp;&amp;(p[i].x-q.x)*(p[(i+1)%n].x-q.x)&lt;eps&amp;&amp;(p[i].y-q.y)*(p[(i+1)%n].y-q.y)&lt;eps) return on_edge; else if (zero(xmult(q,q2,p[i]))) break; else if (xmult(q,p[i],q2)*xmult(q,p[(i+1)%n],q2)&lt;-eps&amp;&amp;xmult(p[i],q,p[(i+1)%n])*xmult(p[i],q2,p[(i+1)%n])&lt;-eps) count++; return count&amp;1;&#125;inline int opposite_side(point p1,point p2,point l1,point l2)&#123; return xmult(l1,p1,l2)*xmult(l1,p2,l2)&lt;-eps;&#125;inline int dot_online_in(point p,point l1,point l2)&#123; return zero(xmult(p,l1,l2))&amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps&amp;&amp;(l1.y-p.y)*(l2.y-p.y)&lt;eps;&#125;//判线段在任意多边形内,顶点按顺时针或逆时针给出,与边界相交返回1int inside_polygon(point l1,point l2,int n,point* p)&#123; point t[MAXN],tt; int i,j,k=0; if (!inside_polygon(l1,n,p)||!inside_polygon(l2,n,p)) return 0; for (i=0;i&lt;n;i++) if (opposite_side(l1,l2,p[i],p[(i+1)%n])&amp;&amp;opposite_side(p[i],p[(i+1)%n],l1,l2)) return 0; else if (dot_online_in(l1,p[i],p[(i+1)%n])) t[k++]=l1; else if (dot_online_in(l2,p[i],p[(i+1)%n])) t[k++]=l2; else if (dot_online_in(p[i],l1,l2)) t[k++]=p[i]; for (i=0;i&lt;k;i++) for (j=i+1;j&lt;k;j++)&#123; tt.x=(t[i].x+t[j].x)/2; tt.y=(t[i].y+t[j].y)/2; if (!inside_polygon(tt,n,p)) return 0; &#125; return 1;&#125;point intersection(line u,line v)&#123; point ret=u.a; double t=((u.a.x-v.a.x)*(v.a.y-v.b.y)-(u.a.y-v.a.y)*(v.a.x-v.b.x)) /((u.a.x-u.b.x)*(v.a.y-v.b.y)-(u.a.y-u.b.y)*(v.a.x-v.b.x)); ret.x+=(u.b.x-u.a.x)*t; ret.y+=(u.b.y-u.a.y)*t; return ret;&#125;point barycenter(point a,point b,point c)&#123; line u,v; u.a.x=(a.x+b.x)/2; u.a.y=(a.y+b.y)/2; u.b=c; v.a.x=(a.x+c.x)/2; v.a.y=(a.y+c.y)/2; v.b=b; return intersection(u,v);&#125;*///多边形重心point barycenter(int n,point* p)&#123; point ret,t; double t1=0,t2; int i; ret.x=ret.y=0; for (i=1;i&lt;n-1;i++) if (fabs(t2=xmult(p[0],p[i],p[i+1]))&gt;eps)&#123; t=barycenter(p[0],p[i],p[i+1]); ret.x+=t.x*t2; ret.y+=t.y*t2; t1+=t2; &#125; if (fabs(t1)&gt;eps) ret.x/=t1,ret.y/=t1; return ret;&#125;int main()&#123; point a[1000]; point q; q.x=0,q.y=1; a[0].x=0,a[0].y=0; a[1].x=0,a[1].y=2; a[2].x=1,a[2].y=2; a[3].x=2,a[3].y=2; a[4].x=2,a[4].y=0; printf(&quot;%d\n&quot;,inside_convex_v2(q,5,a)); return 0;&#125; 面积1234567891011121314151617181920212223242526272829#include &lt;math.h&gt;struct point&#123;double x,y;&#125;;//计算cross product (P1-P0)x(P2-P0)(叉积） double xmult(point p1,point p2,point p0)&#123; return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125;double xmult(double x1,double y1,double x2,double y2,double x0,double y0)&#123; return (x1-x0)*(y2-y0)-(x2-x0)*(y1-y0);&#125;//计算三角形面积,输入三顶点double area_triangle(point p1,point p2,point p3)&#123; return fabs(xmult(p1,p2,p3))/2;&#125;double area_triangle(double x1,double y1,double x2,double y2,double x3,double y3)&#123; return fabs(xmult(x1,y1,x2,y2,x3,y3))/2;&#125;//计算三角形面积,输入三边长double area_triangle(double a,double b,double c)&#123; double s=(a+b+c)/2; return sqrt(s*(s-a)*(s-b)*(s-c));&#125;//计算多边形面积,顶点按顺时针或逆时针给出double area_polygon(int n,point* p)&#123; double s1=0,s2=0; int i; for (i=0;i&lt;n;i++) s1+=p[(i+1)%n].y*p[i].x,s2+=p[(i+1)%n].y*p[(i+2)%n].x; return fabs(s1-s2)/2;&#125; 圆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;math.h&gt;const double pi=acos(-1);//计算圆心角lat表示纬度,-90&lt;=w&lt;=90,lng表示经度//返回两点所在大圆劣弧对应圆心角,0&lt;=angle&lt;=pidouble angle(double lng1,double lat1,double lng2,double lat2)&#123; double dlng=fabs(lng1-lng2)*pi/180; while (dlng&gt;=pi+pi) dlng-=pi+pi; if (dlng&gt;pi) dlng=pi+pi-dlng; lat1*=pi/180,lat2*=pi/180; return acos(cos(lat1)*cos(lat2)*cos(dlng)+sin(lat1)*sin(lat2));&#125;//计算距离,r为球半径double line_dist(double r,double lng1,double lat1,double lng2,double lat2)&#123; double dlng=fabs(lng1-lng2)*pi/180; while (dlng&gt;=pi+pi) dlng-=pi+pi; if (dlng&gt;pi) dlng=pi+pi-dlng; lat1*=pi/180,lat2*=pi/180; return r*sqrt(2-2*(cos(lat1)*cos(lat2)*cos(dlng)+sin(lat1)*sin(lat2)));&#125;//计算球面距离,r为球半径inline double sphere_dist(double r,double lng1,double lat1,double lng2,double lat2)&#123; return r*angle(lng1,lat1,lng2,lat2);&#125;//球面反射/*宇宙探险家们在一次任务中发现了M行星上的一个巨大的地牢，地牢的一个大厅中充满了闪闪发光的小球。探险家们发现光线在小球表面反射时遵循光的镜面反射规律（入射角=反射角）。根据古老的传说，如果将光线以恰当的顺序在小球之间反射，那么通道一间隐藏着古老的珍贵知识的房间的门就会开启。放心，你的任务不是去猜这个恰当的顺序是什么。你的任务简单得多，你被告知小球的位置和半径，以及入射光线的光源位置和方向，然后你要找出光线在小球上反射的序列。输入第一行包含一个整数 n (1≤n≤50) 代表小球总数。 接下来 n 行包括小球的坐标和半径xi, yi, zi, ri (这些整数的绝对值不超过10000)。最后一行有6个实数 - 两个点的坐标。第一个点是入射点。第二个点表示光线的方向 (光线从第一个点直接指向第二个点)。光源不会在任何小球内部。输出你的程序必须输出小球编号组成的序列 (小球从1起按照输入的顺序编号)，也就是光反射的顺序。如果光反射了超过10次，你只需要输出前10个再加上 &apos;etc.&apos; (引号不算)。 注意：如果光以切线方向射向小球，你也要认为他在球上反射了。*/#include &lt;cstdio&gt;#include &lt;cmath&gt;const int size = 555;const double eps = 1e-9;struct point &#123;double x, y, z;&#125; centre = &#123;0, 0, 0&#125;;struct circle &#123;point o; double r;&#125; cir[size];struct ray &#123;point s, dir;&#125; l;int n;int dcmp (double x)&#123;return x &lt; -eps ? -1 : x &gt; eps;&#125;double sqr (double x)&#123;return x*x;&#125;double dot (point a, point b)&#123;return a.x * b.x + a.y * b.y + a.z * b.z;&#125;double dis2 (point a, point b)&#123;return sqr(a.x-b.x) + sqr(a.y-b.y) + sqr(a.z-b.z);&#125;double disToLine2 (point a, ray l)&#123; /**** 点到直线L的距离的平方 **/ point tmp; tmp.x = l.dir.y * (a.z - l.s.z) - l.dir.z * (a.y - l.s.y); tmp.y = -l.dir.x * (a.z - l.s.z) + l.dir.z * (a.x - l.s.x); tmp.z = l.dir.x * (a.y - l.s.y) - l.dir.y * (a.x - l.s.x); return dis2 (tmp, centre) / dis2 (l.dir, centre);&#125;/**** 用向量法求交点 ***/bool find (circle p, ray l, double &amp;k, point &amp;t)&#123; double h2 = disToLine2 (p.o, l); if (dcmp(p.r*p.r - h2) &lt; 0) return false; point tmp; tmp.x = p.o.x - l.s.x; tmp.y = p.o.y - l.s.y; tmp.z = p.o.z - l.s.z; if (dcmp(dot(tmp, l.dir)) &lt;= 0) return false; k = sqrt(dis2(p.o, l.s) - h2) - sqrt(p.r*p.r - h2); double k1 = k / sqrt(dis2(l.dir, centre)); t.x = l.s.x + k1 * l.dir.x; t.y = l.s.y + k1 * l.dir.y; t.z = l.s.z + k1 * l.dir.z; return true; &#125;/*计算新射线的起点和方向 */void newRay (ray &amp;l, ray l1, point inter)&#123; double k = - 2 * dot(l.dir, l1.dir); l.dir.x += l1.dir.x * k; l.dir.y += l1.dir.y * k; l.dir.z += l1.dir.z * k; l.s = inter;&#125;/* 返回的是最先相交的球的编号,均不相交,返回-1 */int update ()&#123; int sign = -1, i; double k = 1e100, tmp; point inter, t; for (i = 1; i &lt;= n; i++)&#123; //找到最先相交的球 if (!find (cir[i], l, tmp, t)) continue; if (dcmp (tmp - k) &lt; 0) k = tmp, inter = t, sign = i; &#125; //ray 变向 if (sign == -1) return sign; ray l1; l1.s = cir[sign].o; l1.dir.x = (inter.x - l1.s.x) / cir[sign].r; l1.dir.y = (inter.y - l1.s.y) / cir[sign].r; l1.dir.z = (inter.z - l1.s.z) / cir[sign].r; newRay (l, l1, inter); return sign;&#125;int main ()&#123; int i; scanf (&quot;%d&quot;, &amp;n); for (i = 1; i &lt;= n; i++) //输入空间的球位置 scanf (&quot;%lf%lf%lf%lf&quot;, &amp;cir[i].o.x, &amp;cir[i].o.y, &amp;cir[i].o.z, &amp;cir[i].r); scanf (&quot;%lf%lf%lf%lf%lf%lf&quot;, &amp;l.s.x, &amp;l.s.y, &amp;l.s.z, &amp;l.dir.x, &amp;l.dir.y, &amp;l.dir.z); for (i = 0; i &lt;= 10; i++)&#123; //最多输出十次相交的球的编号 int sign = update (); if (sign == -1) break; if (i == 0) printf (&quot;%d&quot;, sign); else if (i &lt; 10) printf (&quot; %d&quot;, sign); else printf (&quot; etc.&quot;); &#125; puts (&quot;&quot;);&#125; 三角形123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;math.h&gt;struct point&#123;double x,y;&#125;;struct line&#123;point a,b;&#125;;double distance(point p1,point p2)&#123; return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));&#125;//交点 point intersection(line u,line v)&#123; point ret=u.a; double t=((u.a.x-v.a.x)*(v.a.y-v.b.y)-(u.a.y-v.a.y)*(v.a.x-v.b.x)) /((u.a.x-u.b.x)*(v.a.y-v.b.y)-(u.a.y-u.b.y)*(v.a.x-v.b.x)); ret.x+=(u.b.x-u.a.x)*t; ret.y+=(u.b.y-u.a.y)*t; return ret;&#125;//外心//三角形三条边的垂直平分线的相交点/*三角形三条边的垂直平分线的交于一点,该点即为三角形外接圆的圆心，外心到三顶点的距离相等。点G是平面ABC上一点，那么点G是⊿ABC外心的充要条件：(向量GA+向量GB)·向量AB= (向量GB+向量GC)·向量BC=(向量GC+向量GA)·向量CA=向量0.*/point circumcenter(point a,point b,point c)&#123; line u,v; u.a.x=(a.x+b.x)/2; u.a.y=(a.y+b.y)/2; u.b.x=u.a.x-a.y+b.y; u.b.y=u.a.y+a.x-b.x; v.a.x=(a.x+c.x)/2; v.a.y=(a.y+c.y)/2; v.b.x=v.a.x-a.y+c.y; v.b.y=v.a.y+a.x-c.x; return intersection(u,v);&#125;//内心//三条内角平分线的交点/*2、三角形的内心到三边的距离相等，都等于内切圆半径r。3、r=S/p。证明：S△ABC=S△OAB+S△OAC+S△OBC=(cr+br+ar)/2=rp4、△ABC中，∠C=90°，r=(a+b-c)/2。5、∠BOC=90°+∠A/2。6、点O是平面ABC上任意一点，点O是△ABC内心的充要条件是：a(向量OA)+b(向量OB)+c(向量OC)=向量0。7、点O是平面ABC上任意一点，点I是△ABC内心的充要条件是：向量OI=[a(向量OA)+b(向量OB)+c(向量OC)]/(a+b+c)。8、△ABC中，A(x1，y1)，B(x2，y2)，C(x3，y3)，那么△ABC内心I的坐标是：[ax1/(a+b+c)+bx2/(a+b+c)+cx3/(a+b+c)，ay1/(a+b+c)+by2/(a+b+c)+cy3/(a+b+c)]。9、(欧拉定理)△ABC中，R和r分别为外接圆为和内切圆的半径，O和I分别为其外心和内心，则OI2=R2-2Rr。10、内角平分线分三边长度关系：如图：△ABC中，AD是∠A的角平分线，D在BC上，a、b、c分别是∠A、∠B、∠C的对边，d=AD。设R1是△ABD的外接圆半径，R2是△ACD的外接圆半径，则有：BD/CD=AB/AC*/point incenter(point a,point b,point c)&#123; line u,v; double m,n; u.a=a; m=atan2(b.y-a.y,b.x-a.x); n=atan2(c.y-a.y,c.x-a.x); u.b.x=u.a.x+cos((m+n)/2); u.b.y=u.a.y+sin((m+n)/2); v.a=b; m=atan2(a.y-b.y,a.x-b.x); n=atan2(c.y-b.y,c.x-b.x); v.b.x=v.a.x+cos((m+n)/2); v.b.y=v.a.y+sin((m+n)/2); return intersection(u,v);&#125;//垂心//三角形的三条高线的交点/*2、三角形的垂心是它垂足三角形的内心；或者说，三角形的内心是它旁心三角形的垂心；3、 垂心H关于三边的对称点，均在△ABC的外接圆上。4、 △ABC中，有六组四点共圆，有三组(每组四个)相似的直角三角形，且AH·HD=BH·HE=CH·HF。5、 H、A、B、C四点中任一点是其余三点为顶点的三角形的垂心(并称这样的四点为一—垂心组)。6、 △ABC，△ABH，△BCH，△ACH的外接圆是等圆。7、 在非直角三角形中，过H的直线交AB、AC所在直线分别于P、Q，则 AB/AP·tanB+AC/AQ·tanC=tanA+tanB+tanC。8、 设O，H分别为△ABC的外心和垂心，则∠BAO=∠HAC，∠ABH=∠OBC，∠BCO=∠HCA。9、 锐角三角形的垂心到三顶点的距离之和等于其内切圆与外接圆半径之和的2倍。10、 锐角三角形的垂心是垂足三角形的内心；锐角三角形的内接三角形(顶点在原三角形的边上)中，以垂足三角形的周长最短（施瓦尔兹三角形，最早在古希腊时期由海伦发现）。11、西姆松定理（西姆松线）：从一点向三角形的三边所引垂线的垂足共线的充要条件是该点落在三角形的外接圆上。12、 设锐角△ABC内有一点P，那么P是垂心的充分必要条件是PB*PC*BC+PB*PA*AB+PA*PC*AC=AB*BC*CA。13、设H为非直角三角形的垂心，且D、E、F分别为H在BC，CA，AB上的射影，H1，H2，H3分别为△AEF，△BDF，△CDE的垂心，则△DEF≌△H1H2H3。14、三角形垂心H的垂足三角形的三边，分别平行于原三角形外接圆在各顶点的切线。15、三角形任一顶点到垂心的距离，等于外心到对边的距离的2倍。（垂心伴随外接圆，必有平行四边形）推论（垂心余弦定理）：锐角三角形ABC的垂心为H，则AH/cosA=BH/cosB=CH/cosC=2R（可引入有向距，推广到任意三角形）16、等边三角形的垂心把三角形的高分成2:1两段，靠近顶点的那段长度为高的三分之二。*/ point perpencenter(point a,point b,point c)&#123; line u,v; u.a=c; u.b.x=u.a.x-a.y+b.y; u.b.y=u.a.y+a.x-b.x; v.a=b; v.b.x=v.a.x-a.y+c.y; v.b.y=v.a.y+a.x-c.x; return intersection(u,v);&#125;//重心//三条中线的交点 //到三角形三顶点距离的平方和最小的点//三角形内到三边距离之积最大的点/*1.重心到顶点的距离与重心到对边中点的距离之比为2：1。2.重心和三角形3个顶点组成的3个三角形面积相等。3.重心到三角形3个顶点距离的平方和最小。4.在平面直角坐标系中，重心的坐标是顶点坐标的算术平均。5.重心是三角形内到三边距离之积最大的点。6.三角形ABC的重心为G，点P为其内部任意一点，则3PG2=(AP2+BP2+CP2)-1/3(AB2+BC2+CA2)。7.在三角形ABC中，过重心G的直线交AB、AC所在直线分别于P、Q，则 AB/AP+AC/AQ=38.从三角形ABC的三个顶点分别向以他们的对边为直径的圆作切线，所得的6个切点为Pi，则Pi均在以重心G为圆心，r=1/18(AB2+BC2+CA2)为半径的圆周上。9、G为三角形ABC的重心,P为三角形ABC所在平面上任意一点，则PA2+PB2+PC2=GA2+GB2+GC2+3PG2。*/point barycenter(point a,point b,point c)&#123; line u,v; u.a.x=(a.x+b.x)/2; u.a.y=(a.y+b.y)/2; u.b=c; v.a.x=(a.x+c.x)/2; v.a.y=(a.y+c.y)/2; v.b=b; return intersection(u,v);&#125;//费马点//到三角形三顶点距离之和最小的点point fermentpoint(point a,point b,point c)&#123; point u,v; double step=fabs(a.x)+fabs(a.y)+fabs(b.x)+fabs(b.y)+fabs(c.x)+fabs(c.y); int i,j,k; u.x=(a.x+b.x+c.x)/3; u.y=(a.y+b.y+c.y)/3; while (step&gt;1e-10) for (k=0;k&lt;10;step/=2,k++) for (i=-1;i&lt;=1;i++) for (j=-1;j&lt;=1;j++)&#123; v.x=u.x+step*i; v.y=u.y+step*j; if (distance(u,a)+distance(u,b)+distance(u,c)&gt;distance(v,a)+distance(v,b)+distance(v,c)) u=v; &#125; return u;&#125; 浮点几何函数库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include &lt;math.h&gt;#define eps 1e-8#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)struct point&#123;double x,y;&#125;;struct line&#123;point a,b;&#125;;//计算cross product (P1-P0)x(P2-P0)叉积 double xmult(point p1,point p2,point p0)&#123; return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125;double xmult(double x1,double y1,double x2,double y2,double x0,double y0)&#123; return (x1-x0)*(y2-y0)-(x2-x0)*(y1-y0);&#125;//计算dot product (P1-P0).(P2-P0) 点积 double dmult(point p1,point p2,point p0)&#123; return (p1.x-p0.x)*(p2.x-p0.x)+(p1.y-p0.y)*(p2.y-p0.y);&#125;double dmult(double x1,double y1,double x2,double y2,double x0,double y0)&#123; return (x1-x0)*(x2-x0)+(y1-y0)*(y2-y0);&#125;//两点距离double distance(point p1,point p2)&#123; return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));&#125;double distance(double x1,double y1,double x2,double y2)&#123; return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));&#125;//判三点共线int dots_inline(point p1,point p2,point p3)&#123; return zero(xmult(p1,p2,p3));&#125;int dots_inline(double x1,double y1,double x2,double y2,double x3,double y3)&#123; return zero(xmult(x1,y1,x2,y2,x3,y3));&#125;//判点是否在线段上,包括端点int dot_online_in(point p,line l)&#123; return zero(xmult(p,l.a,l.b))&amp;&amp;(l.a.x-p.x)*(l.b.x-p.x)&lt;eps&amp;&amp;(l.a.y-p.y)*(l.b.y-p.y)&lt;eps;&#125;int dot_online_in(point p,point l1,point l2)&#123; return zero(xmult(p,l1,l2))&amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps&amp;&amp;(l1.y-p.y)*(l2.y-p.y)&lt;eps;&#125;int dot_online_in(double x,double y,double x1,double y1,double x2,double y2)&#123; return zero(xmult(x,y,x1,y1,x2,y2))&amp;&amp;(x1-x)*(x2-x)&lt;eps&amp;&amp;(y1-y)*(y2-y)&lt;eps;&#125;//判点是否在线段上,不包括端点int dot_online_ex(point p,line l)&#123; return dot_online_in(p,l)&amp;&amp;(!zero(p.x-l.a.x)||!zero(p.y-l.a.y))&amp;&amp;(!zero(p.x-l.b.x)||!zero(p.y-l.b.y));&#125;int dot_online_ex(point p,point l1,point l2)&#123; return dot_online_in(p,l1,l2)&amp;&amp;(!zero(p.x-l1.x)||!zero(p.y-l1.y))&amp;&amp;(!zero(p.x-l2.x)||!zero(p.y-l2.y));&#125;int dot_online_ex(double x,double y,double x1,double y1,double x2,double y2)&#123; return dot_online_in(x,y,x1,y1,x2,y2)&amp;&amp;(!zero(x-x1)||!zero(y-y1))&amp;&amp;(!zero(x-x2)||!zero(y-y2));&#125;//判两点在线段同侧,点在线段上返回0int same_side(point p1,point p2,line l)&#123; return xmult(l.a,p1,l.b)*xmult(l.a,p2,l.b)&gt;eps;&#125;int same_side(point p1,point p2,point l1,point l2)&#123; return xmult(l1,p1,l2)*xmult(l1,p2,l2)&gt;eps;&#125;//判两点在线段异侧,点在线段上返回0int opposite_side(point p1,point p2,line l)&#123; return xmult(l.a,p1,l.b)*xmult(l.a,p2,l.b)&lt;-eps;&#125;int opposite_side(point p1,point p2,point l1,point l2)&#123; return xmult(l1,p1,l2)*xmult(l1,p2,l2)&lt;-eps;&#125;//判两直线平行int parallel(line u,line v)&#123; return zero((u.a.x-u.b.x)*(v.a.y-v.b.y)-(v.a.x-v.b.x)*(u.a.y-u.b.y));&#125;int parallel(point u1,point u2,point v1,point v2)&#123; return zero((u1.x-u2.x)*(v1.y-v2.y)-(v1.x-v2.x)*(u1.y-u2.y));&#125;//判两直线垂直int perpendicular(line u,line v)&#123; return zero((u.a.x-u.b.x)*(v.a.x-v.b.x)+(u.a.y-u.b.y)*(v.a.y-v.b.y));&#125;int perpendicular(point u1,point u2,point v1,point v2)&#123; return zero((u1.x-u2.x)*(v1.x-v2.x)+(u1.y-u2.y)*(v1.y-v2.y));&#125;//判两线段相交,包括端点和部分重合int intersect_in(line u,line v)&#123; if (!dots_inline(u.a,u.b,v.a)||!dots_inline(u.a,u.b,v.b)) return !same_side(u.a,u.b,v)&amp;&amp;!same_side(v.a,v.b,u); return dot_online_in(u.a,v)||dot_online_in(u.b,v)||dot_online_in(v.a,u)||dot_online_in(v.b,u);&#125;int intersect_in(point u1,point u2,point v1,point v2)&#123; if (!dots_inline(u1,u2,v1)||!dots_inline(u1,u2,v2)) return !same_side(u1,u2,v1,v2)&amp;&amp;!same_side(v1,v2,u1,u2); return dot_online_in(u1,v1,v2)||dot_online_in(u2,v1,v2)||dot_online_in(v1,u1,u2)||dot_online_in(v2,u1,u2);&#125;//判两线段相交,不包括端点和部分重合int intersect_ex(line u,line v)&#123; return opposite_side(u.a,u.b,v)&amp;&amp;opposite_side(v.a,v.b,u);&#125;int intersect_ex(point u1,point u2,point v1,point v2)&#123; return opposite_side(u1,u2,v1,v2)&amp;&amp;opposite_side(v1,v2,u1,u2);&#125;//计算两直线交点,注意事先判断直线是否平行!//线段交点请另外判线段相交(同时还是要判断是否平行!)point intersection(line u,line v)&#123; point ret=u.a; double t=((u.a.x-v.a.x)*(v.a.y-v.b.y)-(u.a.y-v.a.y)*(v.a.x-v.b.x)) /((u.a.x-u.b.x)*(v.a.y-v.b.y)-(u.a.y-u.b.y)*(v.a.x-v.b.x)); ret.x+=(u.b.x-u.a.x)*t; ret.y+=(u.b.y-u.a.y)*t; return ret;&#125;point intersection(point u1,point u2,point v1,point v2)&#123; point ret=u1; double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x)) /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x)); ret.x+=(u2.x-u1.x)*t; ret.y+=(u2.y-u1.y)*t; return ret;&#125;//点到直线上的最近点(垂点坐标） point ptoline(point p,line l)&#123; point t=p; t.x+=l.a.y-l.b.y,t.y+=l.b.x-l.a.x; return intersection(p,t,l.a,l.b);&#125;point ptoline(point p,point l1,point l2)&#123; point t=p; t.x+=l1.y-l2.y,t.y+=l2.x-l1.x; return intersection(p,t,l1,l2);&#125;//点到直线距离double disptoline(point p,line l)&#123; return fabs(xmult(p,l.a,l.b))/distance(l.a,l.b);&#125;double disptoline(point p,point l1,point l2)&#123; return fabs(xmult(p,l1,l2))/distance(l1,l2);&#125;double disptoline(double x,double y,double x1,double y1,double x2,double y2)&#123; return fabs(xmult(x,y,x1,y1,x2,y2))/distance(x1,y1,x2,y2);&#125;//点到线段上的最近点point ptoseg(point p,line l)&#123; point t=p; t.x+=l.a.y-l.b.y,t.y+=l.b.x-l.a.x; if (xmult(l.a,t,p)*xmult(l.b,t,p)&gt;eps) return distance(p,l.a)&lt;distance(p,l.b)?l.a:l.b; return intersection(p,t,l.a,l.b);&#125;point ptoseg(point p,point l1,point l2)&#123; point t=p; t.x+=l1.y-l2.y,t.y+=l2.x-l1.x; if (xmult(l1,t,p)*xmult(l2,t,p)&gt;eps) return distance(p,l1)&lt;distance(p,l2)?l1:l2; return intersection(p,t,l1,l2);&#125;//点到线段距离double disptoseg(point p,line l)&#123; point t=p; t.x+=l.a.y-l.b.y,t.y+=l.b.x-l.a.x; if (xmult(l.a,t,p)*xmult(l.b,t,p)&gt;eps) return distance(p,l.a)&lt;distance(p,l.b)?distance(p,l.a):distance(p,l.b); return fabs(xmult(p,l.a,l.b))/distance(l.a,l.b);&#125;double disptoseg(point p,point l1,point l2)&#123; point t=p; t.x+=l1.y-l2.y,t.y+=l2.x-l1.x; if (xmult(l1,t,p)*xmult(l2,t,p)&gt;eps) return distance(p,l1)&lt;distance(p,l2)?distance(p,l1):distance(p,l2); return fabs(xmult(p,l1,l2))/distance(l1,l2);&#125;//矢量V以P为顶点逆时针旋转angle并放大scale倍point rotate(point v,point p,double angle,double scale)&#123; point ret=p; v.x-=p.x,v.y-=p.y; p.x=scale*cos(angle); p.y=scale*sin(angle); ret.x+=v.x*p.x-v.y*p.y; ret.y+=v.x*p.y+v.y*p.x; return ret;&#125;//p点关于直线L的对称点ponit symmetricalPointofLine(point p, line L)&#123; point p2; double d; d = L.a * L.a + L.b * L.b; p2.x = (L.b * L.b * p.x - L.a * L.a * p.x - 2 * L.a * L.b * p.y - 2 * L.a * L.c) / d; p2.y = (L.a * L.a * p.y - L.b * L.b * p.y - 2 * L.a * L.b * p.x - 2 * L.b * L.c) / d; return p2;&#125;//求两点的平分线line bisector(point&amp; a, point&amp; b) &#123; line ab, ans; ab.set(a, b); double midx = (a.x + b.x)/2.0, midy = (a.y + b.y)/2.0; ans.a = -ab.b, ans.b = -ab.a, ans.c = -ab.b * midx + ab.a * midy; return ans;&#125;//已知入射线、镜面，求反射线。 //a1,b1,c1为镜面直线方程(a1 x + b1 y + c1 = 0 ,下同)系数; //a2,b2,c2为入射光直线方程系数; //a,b,c为反射光直线方程系数. //光是有方向的，使用时注意：入射光向量:&lt;-b2,a2&gt;；反射光向量:&lt;b,-a&gt;. //不要忘记结果中可能会有&quot;negative zeros&quot; -0void reflect(double a1,double b1,double c1,double a2,double b2,double c2,double &amp;a,double &amp;b,double &amp;c) &#123; double n,m; double tpb,tpa; tpb=b1*b2+a1*a2; tpa=a2*b1-a1*b2; m=(tpb*b1+tpa*a1)/(b1*b1+a1*a1); n=(tpa*b1-tpb*a1)/(b1*b1+a1*a1); if(fabs(a1*b2-a2*b1)&lt;1e-20) &#123; a=a2;b=b2;c=c2; return; &#125; double xx,yy; //(xx,yy)是入射线与镜面的交点。 xx=(b1*c2-b2*c1)/(a1*b2-a2*b1); yy=(a2*c1-a1*c2)/(a1*b2-a2*b1); a=n; b=-m; c=m*yy-xx*n; &#125; 三分123456789//这里以在一个凸性序列中查找元素为例int find(int l,int r,int v)//l存储上界，r存储下界，v即为目标元素&#123; if(l&gt;=r) return l;//返回答案 int midl=(l+r)&gt;&gt;1,midr=(midl+r)&gt;&gt;1; //比较midl与midr的大小 if(sum[midl]&gt;sum[midr]) return find(l,midr);//若midl大于midr，说明最大值在左侧区间 return find(midl,r);//反之，说明最大值在右侧区间&#125; 拉格朗日插值（已知f(x)上的n+1个点（xi,yi）i∈[0,n] ，求f(xi)）12345678910111213int lagrange(int n, int *x, int *y, int xi) &#123; int ans = 0; for (int i = 0; i &lt;= n; i++) &#123; int s1 = 1, s2 = 1; for (int j = 0; j &lt;= n; j++) if (i != j) &#123; s1 = 1ll*s1*(xi-x[j])%mod; s2 = 1ll*s2*(x[i]-x[j])%mod; &#125; ans = (1ll*ans+1ll*y[i]*s1%mod*quick_pow(s2, mod-2)%mod)%mod; &#125; return (ans+mod)%mod;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//求系数#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define O 1llusing namespace std;const int N=2005,mod=998244353;int n,k,x[N],y[N],num[N],tmp[N],res[N],inv[N];void Add(int &amp;x,int y)&#123; x+=y; if(x&gt;=mod) x-=mod;&#125;void exGCD(int a,int b,int &amp;x,int &amp;y)&#123; if(!b) x=1,y=0; else exGCD(b,a%b,y,x),y-=a/b*x;&#125;int Inv(int x)&#123; int xx,yy; exGCD(x,mod,xx,yy); Add(xx,mod); return xx;&#125;void Lagrange()&#123; for(int i=1;i&lt;=n;i++) &#123; int den=1,lst=0; for(int j=1;j&lt;=n;j++) if(i!=j) den=O*den*(x[i]-x[j]+mod)%mod; den=O*y[i]*Inv(den)%mod; for(int j=0;j&lt;n;j++) &#123; tmp[j]=O*(num[j]-lst+mod)*inv[i]%mod; Add(res[j],O*den*tmp[j]%mod),lst=tmp[j]; &#125; &#125;&#125;void Pre()&#123; num[0]=1; for(int i=1;i&lt;=n;swap(num,tmp),i++) &#123; tmp[0]=0; inv[i]=Inv(mod-x[i]); for(int j=1;j&lt;=i;j++) tmp[j]=num[j-1]; for(int j=0;j&lt;=i;j++) Add(tmp[j],O*num[j]*(mod-x[i])%mod); &#125;&#125;int Calc(int x)&#123; int ret=0,var=1; for(int i=0;i&lt;n;var=O*var*x%mod,i++) Add(ret,O*var*res[i]%mod); return ret;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]); Pre(),Lagrange(),printf(&quot;%d&quot;,Calc(k)); return 0;&#125; 素数筛1234567891011for(int i=2;i&lt;=n;i++)&#123; if(!prime[i]) isprime[++num]=i; for(int j=1;j&lt;=num&amp;&amp;i*isprime[j]&lt;=n;j++) &#123; prime[i*isprime[j]]=1; if(i%isprime[j]==0) break; &#125; &#125; 数论####二次剩余123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162/*hdu 3930 题意： 给定newx, k, m, 方程 (x^k)%m=newx, 求在模m意义下的所有解x。 限制： 0 &lt;= newx, m, k &lt;= 1.5*10^15; m是素数。 思路： N次剩余 */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;#define LL __int64#define PB push_backLL mul(LL a,LL b,LL m)&#123; LL ret = 0; a %= m; while(b)&#123; if(b &amp; 1) ret = (ret + a) % m; a = (a + a) % m; b &gt;&gt;= 1; &#125; return ret;&#125;LL a_b_MOD_c(LL a,LL b,LL m)&#123; LL ret = 1; a %= m; while(b)&#123; if(b&amp;1) ret = mul(ret,a,m); a = mul(a,a,m); b &gt;&gt;= 1; &#125; return ret;&#125;LL ext_gcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if(b==0) &#123; x=1, y=0; return a; &#125; LL ret= ext_gcd(b,a%b,y,x); y-= a/b*x; return ret;&#125;vector&lt;LL&gt; a;bool g_test(LL g,LL p)&#123; for(LL i=0;i&lt;a.size();++i) if(a_b_MOD_c(g,(p-1)/a[i],p)==1) return 0; return 1;&#125;LL pri_root(LL p)&#123; a.clear(); LL tmp=p-1; for(LL i=2;i&lt;=tmp/i;++i) if(tmp%i==0)&#123; a.push_back(i); while(tmp%i==0) tmp/=i; &#125; if(tmp!=1) a.push_back(tmp); LL g=1; while(true)&#123; if(g_test(g,p)) return g; ++g; &#125;&#125;const int HASH_MOD=9876543;LL key[HASH_MOD], val[HASH_MOD];int head[HASH_MOD], next[HASH_MOD];struct Hash&#123; int tot; void init()&#123; memset(head, -1, sizeof(head)); tot = 0; &#125; LL insert(LL x, LL y)&#123; int k = x % HASH_MOD; key[tot] = x; val[tot] = y; next[tot] = head[k]; head[k] = tot++; &#125; LL find(LL x)&#123; int k = x % HASH_MOD; for(int i = head[k]; i != -1; i = next[i]) if(key[i] == x) return val[i]; return -1; &#125;&#125;hs;//求解模方程a^x=b(mod m),n为素数,无解返回-1 //注意：要求0 &lt; a &lt; m; 0 &lt;= b &lt; m; 否则按题意自己转化。//复杂度O(sqrt(m))LL log_mod(LL a, LL b, LL m)&#123; hs.init(); LL s = ceil(sqrt(m + 0.5)); LL cur = 1; for (int i = 0; i &lt; s; ++i)&#123; if(hs.find(cur)==-1) hs.insert(cur,i); //记得先判重，在插入 cur = cur * a % m; &#125; LL v = a_b_MOD_c(a, (m - s - 1 + m) % m, m); for(int i = 0; i &lt; s; ++i)&#123; LL tmp = hs.find(b); if(tmp!=-1) return s * i + tmp; b=b*v%m; &#125; return -1;&#125;/*n次剩余 任务： 给定N, a, p, 求出(x^N)%p=a 在模p意义下的所有解x。 说明： 令g为p的原根，因为p为素数，所以phi(p)=p-1。 由原根的性质得： 如果g为p的原根，则：g^i mod p != g^j mod p (p为素数), 其中i != j且i, j介於1至(p-1)之间 所以，可以设g^y=x, g^t=a，则有： g^(y*N)%p=g^t 又由原根的性质： g^(y*N)%p=g^t -&gt; (y*N)%(p-1)=t (此方程可以由拓展欧几里得解) 另外g^t=a可以由离散对数求出 */vector&lt;LL&gt; residue(LL p, LL N, LL a)&#123; LL g = pri_root(p); g %= p; LL m = log_mod(g, a, p); vector&lt;LL&gt; ret; if(a == 0)&#123; ret.PB(0); return ret; &#125; if(m == -1) return ret; LL A = N, B = p - 1, C = m, x, y; LL d = ext_gcd(A, B, x, y); if(C % d != 0) return ret; x = x * (C / d) % B; LL delta = B / d; for(int i = 0; i &lt; d; ++i)&#123; x = ((x + delta) % B + B) % B; ret.PB(a_b_MOD_c(g, x, p)); &#125; sort(ret.begin(), ret.end()); ret.erase(unique(ret.begin(), ret.end()), ret.end()); return ret;&#125;int main()&#123; int cas = 0; LL k,m,newx; while(scanf(&quot;%I64d%I64d%I64d&quot;,&amp;k, &amp;m, &amp;newx)!=EOF)&#123; vector&lt;LL&gt; ans; ans = residue(m,k,newx); printf(&quot;case%d:\n&quot;,++cas); if(ans.size()==0) puts(&quot;-1&quot;); for(int i = 0; i &lt; ans.size(); ++i) printf(&quot;%I64d\n&quot;,ans[i]); &#125; return 0;&#125; 欧拉降幂123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960612^（2^（2^（2^2）））%p#include&lt;bits/stdc++.h&gt;#define lst long long#define ldb double#define N 10000050#define M 10000000using namespace std;const int Inf=1e9;int read()&#123; int s=0,m=0;char ch=getchar(); while(!isdigit(ch))&#123;if(ch==&apos;-&apos;)m=1;ch=getchar();&#125; while( isdigit(ch))s=(s&lt;&lt;3)+(s&lt;&lt;1)+(ch^48),ch=getchar(); return m?-s:s;&#125;int Q,tot;int phi[N],pri[N];void Prepare_Phi()&#123; phi[1]=1; for(int i=2;i&lt;=M;++i) &#123; if(!phi[i])pri[++tot]=i,phi[i]=i-1;//① for(int j=1;j&lt;=tot;++j) &#123; if(i*pri[j]&gt;M)break; if(!(i%pri[j])) &#123; phi[i*pri[j]]=phi[i]*pri[j];//② break; &#125;else phi[i*pri[j]]=phi[i]*(pri[j]-1);//③ &#125; &#125;&#125;lst qpow(lst x,lst y,lst mod)&#123; lst ret=1; while(y) &#123; if(y&amp;1)ret=ret*x%mod; x=x*x%mod,y&gt;&gt;=1; &#125;return ret;&#125;lst Solve(lst mod)&#123; if(mod==1)return 0; return qpow(2,Solve(phi[mod])+phi[mod],mod);&#125;int main()&#123; Prepare_Phi(); Q=read(); while(Q--) &#123; int p=read(); printf(&quot;%lld\n&quot;,Solve(p)); &#125; return 0;&#125; 阶乘因式分解（给你n,m，问n的阶乘中有多少个因子为m）12345while(n)&#123; sum+=n/m; n/=m;&#125; 连分数逼近法 3.245 的连分数是 [3; 4, 12, 4] 3+1/(4+(1/(12+1/4)))1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define ling 1e-8int main()&#123; double s; int a[1000]; //或者scanf(&quot;%d%d&quot;,&amp;a,&amp;b); 令s=a*1.0/(b*1.0); while (scanf(&quot;%lf&quot;,&amp;s)==1) &#123; int i=0; while (fabs(s)&gt;ling) &#123; a[i++]=(int)s; s=1/(s-(int)s); &#125; for (int j=0;j&lt;i-1;j++) cout&lt;&lt;a[j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; return 0;&#125; 欧拉函数欧拉函数是小于x的整数中与x互质的数的个数欧拉函数的几个性质1.对于质数p，φ(p)=p−1φ(p)=p−1 φ(p)=p-1φ(p)=p−1。2.若p为质数，n=pkn=pk n=p^kn=pk，则φ(n)φ(n) φ(n)φ(n)=pkpk p^kpk-pk−1pk−1 p^{k-1}pk−1。3.欧拉函数是积性函数，但不是完全积性函数。若m,n互质，则φ(m∗n)=φ(m)∗φ(n)φ(m∗n)=φ(m)∗φ(n) φ(mn)=φ(m)φ(n)φ(m∗n)=φ(m)∗φ(n)。特殊的，当m=2，n为奇数时，φ(2n)=φ(n)。4.当n&gt;2时，φ(n)是偶数。5.小于n的数中，与n互质的数的总和为：φ(n) n / 2 (n&gt;1)。6.n=∑d∣n φ(d)n=∑d∣n φ(d)即n的因数（包括1和它自己）的欧拉函数之和等于n。 单个求解欧拉函数12345678int eurlar(int x)&#123; int ret=x; for (int i=2;i&lt;=sqrt(x)&amp;&amp;x&gt;1;i++) if (x%i==0) &#123;ret=ret/i*(i-1); while (x%i==0) x/=i;&#125; if (x&gt;1) ret=ret/x*(x-1); return ret;&#125; 埃拉托斯特尼筛求欧拉函数(o(n)lnln)1234567891011121314void euler(int n)//phi[i]代表i的欧拉值，&#123; for (int i=1;i&lt;=n;i++) phi[i]=i; for (int i=2;i&lt;=n;i++) &#123; if (phi[i]==i)//这代表i是质数 &#123; for (int j=i;j&lt;=n;j+=i) &#123; phi[j]=phi[j]/i*(i-1);//把i的倍数更新掉 &#125; &#125; &#125;&#125; 欧拉筛求欧拉函数（o(n)）1234567891011121314151617181920212223void euler(int n)//flag[i]代表i是否为质数，prime存的质数，phi[i]代表i的欧拉值&#123; int num=0; phi[1]=1;//1要特判 for (int i=2;i&lt;=n;i++) &#123; if (flag[i]==0)//这代表i是质数 &#123; prime[++num]=i; phi[i]=i-1; &#125; for (int j=1;j&lt;=num&amp;&amp;prime[j]*i&lt;=n;j++)//经典的欧拉筛写法 &#123; flag[i*prime[j]]=1;//先把这个合数标记掉 if (i%prime[j]==0) &#123; phi[i*prime[j]]=phi[i]*prime[j];//若prime[j]是i的质因子，则根据计算公式，i已经包括i*prime[j]的所有质因子 break;//经典欧拉筛的核心语句，这样能保证每个数只会被自己最小的因子筛掉一次 &#125; else phi[i*prime[j]]=phi[i]*phi[prime[j]];//利用了欧拉函数是个积性函数的性质 &#125; &#125;&#125; 中国剩余定理中国剩余定理求x的最小非负整数解 //求M%A=a,M%B=b,…中的M，其中A,B,C…互质1234567891011121314int CRT(int a[],int m[],int n)&#123; int M = 1; int ans = 0; for(int i=1; i&lt;=n; i++) M *= m[i]; for(int i=1; i&lt;=n; i++)&#123; int x, y; int Mi = M / m[i]; ex_gcd(Mi, m[i], x, y); ans = (ans + Mi * x * a[i]) % M; &#125; if(ans &lt; 0) ans += M; return ans; &#125; 扩展中国剩余定理//求M%A=a,M%B=b,…中的M，其中A,B,C…不互质12345678910111213141516171819202122232425262728293031bool merge(LL a1, LL m1, LL a2, LL m2, LL &amp;a3, LL &amp;m3) &#123; LL d = gcd(m1, m2); LL c = a2 - a1; if(c % d) return false; c = (c % m2 + m2) % m2; m1 /= d; m2 /= d; c /= d; c *= Inv(m1, m2);//Inv为乘法逆元，数论常用内容——欧几里得算法与扩展欧几里得算法 c %= m2; c *= m1 * d; c += a1; m3 = m1 * m2 * d; a3 = (c % m3 + m3) % m3; return true; &#125; LL CRT(LL a[], LL m[], int n) &#123; LL a1 = a[1]; LL m1 = m[1]; for(int i=2; i&lt;=n; i++) &#123; LL a2 = a[i]; LL m2 = m[i]; LL m3, a3; if(!merge(a1, m1, a2, m2, a3, m3)) return -1; a1 = a3; m1 = m3; &#125; return (a1 % m1 + m1) % m1; &#125; 大素数 米勒拉宾素数测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const int S=8;//一般8-10个伪素数就行（斌巨的）long long mult_mod(long long a, long long b, long long c) &#123; a %= c; b %= c; long long ret = 0, tmp = a; while(b) &#123; if(b &amp; 1) &#123; ret += tmp; if(ret &gt; c) ret -= c; &#125; tmp &lt;&lt;= 1; if(tmp &gt; c) tmp -= c; b &gt;&gt;= 1; &#125; return ret;&#125;long long int quick_pow(long long int a,long long int n,long long int mod)//快速幂 &#123; long long ret = 1, tmp = a % mod; while(n) &#123; if(n &amp; 1) ret = mult_mod(ret, tmp, mod); tmp = mult_mod(tmp, tmp, mod); n &gt;&gt;= 1; &#125; return ret;&#125;bool check(long long a,long long n,long long x,long long t)&#123; long long ret = quick_pow(a, x, n); long long last = ret; for(int i = 1; i &lt;= t; ++i) &#123; ret = mult_mod(ret, ret, n); if(ret == 1 &amp;&amp; last != 1 &amp;&amp; last != n - 1) return true; last = ret; &#125; if(ret != 1) return true; else return false;&#125;bool Miller_Rabbin(long long int n)//米勒拉宾素数测试 &#123; if(n&lt;2) return false; if(n==2) return true; if((n&amp;1)==0) return false; long long int x=n-1; long long t=0; while((x&amp;1)==0) &#123; x&gt;&gt;=1;t++; &#125; srand(time(NULL)); for(int i=0;i&lt;S;i++)&#123; long long a=rand()%(n-1)+1; if(check(a,n,x,t)) return false; &#125; return true;&#125; //ab%mod(可能modmod超long long )long long ksc(long long a, long long b, long long mod){ long long res = 0; while(b){ if(b&amp;1) res = (res + a)%mod; (a&lt;&lt;=1)%=mod; b &gt;&gt;= 1; } return res;}12345678910111213141516171819202122232425262728293031323334353637383940ll quick_pow(ll a,ll b,ll r)//快速幂 &#123; ll ans = 1; while(b) &#123; if(b&amp;1)ans=(ans*a)%r; a = (a*a)%r; b&gt;&gt;=1; &#125; return ans;&#125;bool Miller_Rabbin(int n,int a)//米勒拉宾素数测试 &#123; int r=0,s=n-1,j; if(!(n%a)) return false; while(!(s&amp;1))&#123; s&gt;&gt;=1; r++; &#125; ll k=qpow(a,s,n); if(k==1) return true; for(j=0;j&lt;r;j++,k=k*k%n) if(k==n-1) return true; return false;&#125;bool IsPrime(int n)//判断是否是素数 &#123; int tab[]=&#123;2,3,5,7&#125;; for(int i=0;i&lt;4;i++) &#123; if(n==tab[i]) return true; if(!Miller_Rabbin(n,tab[i])) return false; &#125; return true;&#125; 佩尔方程（x^2-dy^2=1)连分数法12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a[20000];bool pell_minimum_solution(ll n,ll &amp;x0,ll &amp;y0)&#123;//求PELL方程最小整数解 ll m=(ll)sqrt((double)n);//M是N的平方根向下取整 if(m*m==n)return false;//当n是完全平方数则佩尔方程无解（不讨论正负一，零） //下面是把N用连分数形式存，B,C,TMP（即AI）的递推见解释以22为例参考 int i=0; //连分数的数位 a[i++]=m; //A0位整数部分m=4 ll b=m,c=1; //B=4即整数部分位,C=1即求RN时的分母 double sq=sqrt(n);//SQ是N的高精度根,相当于r0 double tmp;//tp在下面的循环就是rn do&#123; c=(n-b*b)/c; tmp=(sq+b)/c; a[i++]=(ll)(floor(tmp)); b=a[i-1]*c-b; //printf(&quot;%lld %lld %lld\n&quot;,a[i-1],b,c); &#125;while(a[i-1]!=2*a[0]);//当有一位等于整数两倍就结束 //下面就是要把连分数形式化成分子分母的形式，求PQ两个值 ll p=1,q=0; for(int j=i-2;j&gt;=0;j--)&#123; ll t=p; p=q+p*a[j]; q=t; //printf(&quot;a[%d]=%lld %lld %lld\n&quot;,j,a[j],p,q); &#125; if((i-1)%2==0)&#123;x0=p;y0=q;&#125;//如果I是奇数，X0与Y0都是0 else&#123;x0=2*p*p+1;y0=2*p*q;&#125;//如果I是偶数，X0是两倍P方+1，y0是两倍PQ return true;&#125;int main()&#123; ll n,x,y; while(~scanf(&quot;%lld&quot;,&amp;n))&#123; if(pell_minimum_solution(n,x,y))&#123;//输入N求X,Y的值，有解就输出 printf(&quot;x=%lld y=%lld\t&quot;,x,y);//x,y printf(&quot;%lld^2-%lld*%lld^2=1\t&quot;,x,n,y);//x^2-n*y^2=1 printf(&quot;%lld-%lld=1\n&quot;,x*x,n*y*y);//(x^2)-(n*y^2)=1 &#125; &#125; return 0;&#125; 暴力法1234567891011121314typedef long long ll;int x,y;void mysearch()&#123; y=1; while(1)&#123; x=(ll)sqrt(d*y*y+1); if(x*x-d*y*y==1)&#123; break; &#125; y++; &#125;&#125; 快速幂1234567int power(int a,int b,int P)&#123; int re=1; for(;b;b&gt;&gt;=1,a=(long long)a*a%P) if(b&amp;1) re=(long long)re*a%P; return re;&#125; exgcd12345678910111213141516171819#include &lt;cstdio&gt;using namespace std;int a,b,c,d,x,y;void exgcd(int a,int b,int &amp;d,int &amp;x,int &amp;y)&#123; if(!b) d=a,x=1,y=0; else exgcd(b,a%b,d,y,x),y-=a/b*x;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); exgcd(a,b,d,x,y); if(!(c%d)) &#123; x*=c/d;y*=c/d;a/=d;b/=d; for(int k=-2;k&lt;=2;k++) printf(&quot;%d %d\n&quot;,x+k*b,y-k*a); &#125;&#125; BM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1000000007;ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;ll _,n;namespace linear_seq&#123; const int N=10010; ll res[N],base[N],_c[N],_md[N]; vector&lt;ll&gt; Md; void mul(ll *a,ll *b,int k) &#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; &#125; int solve(ll n,VI a,VI b) &#123; ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt;p&gt;=0;p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (int i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans; &#125; VI BM(VI s) &#123; VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; int gao(VI a,ll n)&#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c))); &#125;&#125;;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld&quot;,&amp;n); vector&lt;int&gt;v; v.push_back(1); //至少8项，越多越好。 v.push_back(5); v.push_back(15); v.push_back(35); v.push_back(70); v.push_back(126); v.push_back(210); v.push_back(330); v.push_back(495); v.push_back(715); printf(&quot;%lld\n&quot;,linear_seq::gao(v,n-1)%mod); &#125;&#125; 组合数学计算数学凸包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;const int N=1e5+5;const double eps=1e-6;int n,top;double len,S;struct Point &#123; double x,y; &#125; a[N],b[N];double dis(Point x,Point y)&#123; return sqrt((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y));&#125;double Cross(Point x,Point y,Point z)&#123; return (x.x-z.x)*(y.y-z.y)-(x.y-z.y)*(y.x-z.x);&#125;double Cross(Point x,Point y)&#123; return x.x*y.y-x.y*y.x;&#125;bool cmp(const Point &amp;x,const Point &amp;y)&#123; double t=Cross(x,y,a[1]);return abs(t)&gt;eps?t&gt;0:dis(a[1],x)&lt;dis(a[1],y);&#125;inline void Graham()&#123; int t=1; for(int i=2;i&lt;=n;i++) if(a[i].x&lt;a[t].x||(a[i].x==a[t].x&amp;&amp;a[i].y&lt;a[t].y)) t=i; if(t!=1) std::swap(a[t],a[1]); std::sort(a+2,a+n+1,cmp); for(int i=1;i&lt;=n;i++) &#123; while(top&gt;1&amp;&amp;Cross(a[i],b[top],b[top-1])&gt;=0) top--; b[++top]=a[i]; &#125; b[top+1]=b[1];&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;a[i].x,&amp;a[i].y); Graham();//求凸包的点 for(int i=1;i&lt;=top;i++) len+=dis(b[i],b[i+1]); printf(&quot;L: %.8lf\n&quot;,len);//求凸包的长度 for(int i=1;i&lt;=top;i++) S+=Cross(b[i],b[i+1]); printf(&quot;S: %.8lf\n&quot;,S/2);//求凸包的面积 &#125; 点旋转123假设对图片上任意点(x,y)，绕一个坐标点(rx0,ry0)逆时针旋转a角度后的新的坐标设为(x0, y0)，有公式： x0= (x - rx0)*cos(a) - (y - ry0)*sin(a) + rx0 ; y0= (x - rx0)*sin(a) + (y - ry0)*cos(a) + ry0 ; 图论最短路Floyd算法，多源无负权12345678910111213141516//通过邻接矩阵跑出所有点之间的最短路,时间复杂度O(n^3),空间复杂度O(n^2)//d[i][j]表示i到j的最短路径长度,初始化：d[i][i]=0,点到点有路按正常权值初始化,其余INFint mp[n][n];int d[n][n];void Floyd()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) d[i][j]=mp[i][j]; for(int k=1;k&lt;=n;k++) //枚举以k为中间点的所有点的最短路 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);&#125; Dijkstra算法,单源无负权12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//适用于边权为正的情况,单源最短路问题//时间复杂度为O(V*V+E)//算法思路:设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，//第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，//以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了）//不断的维护一个dis数组，最后得到的dis数组中dis[i]就是源点到图中节点i的最短路径的长度//记录vis数组判断当前点是否访问过int mp[n][n];int dis[n];int vis[n];void init()&#123; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(i==j) mp[i][j]=0; else mp[i][j]=INF; &#125; &#125;&#125;int djs(int st,int ed)&#123; for(int i=1;i&lt;=n;i++) &#123; dis[i]=mp[st][i]; vis[i]=0; &#125; vis[st]=1; for(int i=1;i&lt;n;i++) //更新dis数组,起点不用更新了,所以是n-1次 &#123; int minn=INF; //更新最小距离点 int next=-1; //确定下一个点 for(int j=1;j&lt;=n;j++) &#123; if(vis[j]==0&amp;&amp;dis[j]&lt;minn) &#123; minn=dis[j]; next=j; &#125; &#125; if(next==-1) //当前已不存在点 continue; vis[next]=1; for(int j=1;j&lt;=n;j++) &#123; if(vis[j]==0) //vis[j]=1已为最短路径 dis[j]=min(dis[j],dis[next]+mp[next][j]); //以next为中间点进行松弛 &#125; &#125; return dis[ed]; //找到st到ed的最短路&#125; SPFA,Bellman-Ford的队列优化,玄学时间复杂度,O(E)-O(VE)之间123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//假设有一个点刚刚被优化了，我们可以很明显的发现，针对这条边，//也就只有这条边的出边上的终点才可以继续被优化，这就给了我们启示，//其实我们可以再维护一个队列，一个点如果被优化过了，那么就进队列，int mp[n][n];int n,m;int dis[n];int vis[n];void init()&#123; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(i==j) mp[i][j]=0; else mp[i][j]=INF; &#125; &#125;&#125;int spfa(int st,int ed)&#123; for(int i=1;i&lt;=n;i++) &#123; dis[i]=INF; vis[i]=0; &#125; dis[st]=0; queue&lt;int&gt;q; q.push(st); vis[st]=1; while(!q.empty()) &#123; int now=q.front(); q.pop(); vis[now]=0; for(int i=1;i&lt;=n;i++) &#123; if(dis[i]&gt;dis[now]+mp[now][i]) &#123; dis[i]=dis[now]+mp[now][i]; if(vis[i]==0) &#123; q.push(i); vis[i]=1; &#125; &#125; &#125; &#125; return dis[ed];&#125; 并查集1234567891011121314151617181920212223242526272829303132333435int par[MAX_N]; //父亲 int rank[MAX_N]; //树的高度//初始化n个元素void init(int n)&#123; for(int i = 0; i &lt; n; i++)&#123; par[i] = i; rank[i] = 0; &#125;&#125; //查询树的根int find(int x)&#123; if(par[x] == x) return x; else return par[x] = find(par[x]);&#125; //合并x和y所属的集合void unite(int x, int y)&#123; x = find(x); y = find(y); if(x == y) return; if(rank[x] &lt; rank[y]) par[x] = y; else par[y] = x; if(rank[x] == rank[y]) rank[x]++;&#125; //判断x和y是否属于同一个集合bool same(int x, int y)&#123; return find(x) == find(y);&#125;]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kunagbin专题一 kmp]]></title>
    <url>%2F2019%2F01%2F26%2Fkunagbin%E4%B8%93%E9%A2%98%E4%B8%80-kmp%2F</url>
    <content type="text"><![CDATA[A B C D E F G H I J K L M N O P √ √ √ √ √ √ √ √ √ √ A - Oulipo简单kmp板子题，求母串里有几个子串 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[1000001];long long int sum;char a[1000001],b[1000001];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j];//j取-1只是为了判断边界，就如果j为0的话会一直循环下去 next[i+1]=j+1;//匹配到第i+1个时，从第i个开始匹配，例如abcabcd 与 abcabce第3个匹配不上，但是前两个匹配得上 &#125;&#125;void KMP()&#123; for(int i=0,j=0;i&lt;n;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=b[j]) j=next[j]; if(j==m-1) sum++; &#125;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; sum=0; memset(next,0,sizeof(next)); scanf(&quot;%s%s&quot;,b,a); //a-&gt;long b-&gt;short n=strlen(a);m=strlen(b); Getnext(); KMP(); printf(&quot;%lld\n&quot;,sum); &#125; return 0;&#125; B - Number Sequence子字符串在母串的位置，板子题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[1000001];long long int sum;int a[1000001],b[1000001];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j];//j取-1只是为了判断边界，就如果j为0的话会一直循环下去 next[i+1]=j+1;//匹配到第i+1个时，从第i个开始匹配，例如abcabcd 与 abcabce第3个匹配不上，但是前两个匹配得上 &#125;&#125;void KMP()&#123; for(int i=0,j=0;i&lt;n;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=b[j]) j=next[j]; if(j==m-1) &#123; sum=i-j+1; return; &#125; &#125;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; sum=0; int i; memset(next,0,sizeof(next)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(i=0;i&lt;m;i++) &#123; scanf(&quot;%d&quot;,&amp;b[i]); &#125; Getnext(); KMP(); if(sum==0) sum=-1; printf(&quot;%lld\n&quot;,sum); &#125; return 0;&#125; C - Period当前位循环节的个数，也是板子题，next数组的应用 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[1000001];long long int sum;char b[1000001];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j]; next[i+1]=j+1; &#125;&#125;int main()&#123; int t,i; for(t=1;;t++) &#123; memset(next,0,sizeof(next)); scanf(&quot;%d&quot;,&amp;m); if(m==0) break; scanf(&quot;%s&quot;,b); printf(&quot;Test case #%d\n&quot;,t); Getnext(); for(i=1;i&lt;=m;i++) &#123; if(next[i]&gt;0) &#123; if(i%(i-next[i])==0) &#123; printf(&quot;%d %d\n&quot;,i,i/(i-next[i])); &#125; &#125; &#125; printf(&quot;\n&quot;); &#125; return 0;&#125; D - Power Strings和c差不多，仍然是求循环节的个数。 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[1000001];long long int sum;char b[1000001];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j]; next[i+1]=j+1; &#125;&#125;int main()&#123; while(1) &#123; int i; memset(next,0,sizeof(next)); scanf(&quot;%s&quot;,b); m=strlen(b); if(b[0]==&apos;.&apos;&amp;&amp;m==1) break; Getnext(); if(m%(m-next[m])==0) &#123; printf(&quot;%d\n&quot;,m/(m-next[m])); &#125; else &#123; printf(&quot;1\n&quot;); &#125; &#125; return 0;&#125; E - Count the string子串在母串的个数和，还是偏板子的思维题。 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[1000001];int men[1000001];long long int sum;char b[1000001];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j]; next[i+1]=j+1; &#125;&#125;int main()&#123; int t,i; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; sum=0; scanf(&quot;%d&quot;,&amp;m); scanf(&quot;%s&quot;,b); Getnext(); for(i=1;i&lt;=m;i++) &#123; //printf(&quot;%d &quot;,next[i]); if(next[i]&gt;0) sum++; &#125; printf(&quot;%lld\n&quot;,(sum+m)%10007); &#125; return 0;&#125; F - Cyclic Nacklace在后面添加几个可以让当前字符串构成循环，注意最后一位。next数组的利用。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;string.h&gt;int next[100005],m;char b[100005];void getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(b[i]!=b[j]&amp;&amp;j!=-1) j=next[j]; next[i+1]=j+1; &#125; return;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; memset(next,0,sizeof(next)); scanf(&quot;%s&quot;,b); m=strlen(b); getnext(); if(m%(m-next[m])==0&amp;&amp;next[m]!=0) &#123; printf(&quot;0\n&quot;); &#125; else &#123; int men=m-next[m]; int j=next[m]%men; printf(&quot;%d\n&quot;,men-j); &#125; &#125; return 0; &#125; G - Simpsons’ Hidden Talents最长前后缀,kmp一次就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;string.h&gt;int next[1000005],m,n,sum;char b[1000005],a[1000005];void getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(b[i]!=b[j]&amp;&amp;j!=-1) j=next[j]; next[i+1]=j+1; &#125; return;&#125;void KMP()&#123; for(int i=0,j=0;i&lt;n;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=b[j]) j=next[j]; sum=j; &#125;&#125;int main()&#123; while(scanf(&quot;%s%s&quot;,b,a)!=EOF) &#123; sum=0; memset(next,0,sizeof(next)); n=strlen(a); m=strlen(b); getnext(); KMP(); for(int i=0;i&lt;=sum;i++) printf(&quot;%c&quot;,b[i]); if(sum&gt;-1) printf(&quot; %d\n&quot;,sum+1); else &#123; printf(&quot;%d\n&quot;,sum+1); &#125; &#125; return 0; &#125; H - Milking Grid求最小覆盖问题，就横竖两次遍历的next数组的应用，然后求他们循环节的最大公倍数，注意，不能超过m,n。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;char a[10005][100];long long int next[10005];int main()&#123; long long int qum=1,sum=1; long long int i,j,m,n; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; scanf(&quot; %c&quot;,&amp;a[i][j]); &#125; &#125; for(i=0;i&lt;n;i++) &#123; memset(next,0,sizeof(next)); next[0]=-1; for(int ii=1,j=0;ii&lt;m;ii++,j++) &#123; while(a[i][ii]!=a[i][j]&amp;&amp;j!=-1) j=next[j]; next[ii+1]=j+1; &#125; sum=((sum/__gcd(sum,(m-next[m])))*((m-next[m]))); if(sum&gt;m) sum=m; &#125; for(i=0;i&lt;m;i++) &#123; memset(next,0,sizeof(next)); next[0]=-1; for(int ii=1,j=0;ii&lt;n;ii++,j++) &#123; while(a[ii][i]!=a[j][i]&amp;&amp;j!=-1) j=next[j]; next[ii+1]=j+1; &#125; qum=((qum/__gcd(qum,(n-next[n])))*(n-next[n])); if(qum&gt;n) qum=n; &#125; printf(&quot;%lld\n&quot;,sum*qum); return 0; &#125; I - Theme Section使输入的字符串满足EAEBE格式的最长E串，next数组的利用，我们可以认为最长为n=next[m]（该字符串的前后缀长度）E（AEB）E，然后从头到尾找是否还有子串满足前后缀长度为n,即找满足EAE格式。如果找不到n–，一直到找到或者n为0 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;string.h&gt;int next[1000005];char a[1000005];int m;void Getnext()&#123; int i,j; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=a[j]) j=next[j]; next[i+1]=j+1; &#125; return;&#125;int main()&#123; int i,j,n,t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%s&quot;,a); m=strlen(a); Getnext(); n=next[m]; for(i=n;i&gt;=0;i--) &#123; for(j=1;j&lt;=m;j++) &#123; if(next[j]==i) break; &#125; if(j&lt;m) &#123; break; &#125; &#125; printf(&quot;%d\n&quot;,i); &#125; return 0;&#125; M - Substring Frequency板子题，子串在母串出现了几次。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;string.h&gt;int next[1000005];char a[1000005];int m;void Getnext()&#123; int i,j; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=a[j]) j=next[j]; next[i+1]=j+1; &#125; return;&#125;int main()&#123; int i,j,n,t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%s&quot;,a); m=strlen(a); Getnext(); n=next[m]; for(i=n;i&gt;=0;i--) &#123; for(j=1;j&lt;=m;j++) &#123; if(next[j]==i) break; &#125; if(j&lt;m) &#123; break; &#125; &#125; printf(&quot;%d\n&quot;,i); &#125; return 0;&#125;]]></content>
      <categories>
        <category>VJ</category>
      </categories>
      <tags>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
