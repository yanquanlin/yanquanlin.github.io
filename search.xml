<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[弱水三千只取一瓢饮]]></title>
    <url>%2F2029%2F02%2F03%2F%E5%BC%B1%E6%B0%B4%E4%B8%89%E5%8D%83%E5%8F%AA%E5%8F%96%E4%B8%80%E7%93%A2%E9%A5%AE%2F</url>
    <content type="text"><![CDATA[2019/2/3 这应该是最为生气的一天，早上8点多才睡着，早饭午饭也没吃，你知道我有多伤心吗？原来在我之外还有一个男朋友的存在，原来你的第一次早就不在了，原来我一直就是小三般的存在，如果不是登了你的qq号，可能很久都没办法知道吧，原来空间情侣，游戏情侣不是你的朋友，而是你的另一个男朋友，说实话，真的受不了这个打击甚至想分手，可是后来，在朋友都劝我分手的时候，我妥协了，因为我真的是喜欢你啊，因为喜欢你，舍不得放弃，舍不得离开你，何怡然，我也不知道这样做是对还是错，但是我，从来就没有想过抛弃你或者说离开你，也没有过二心，每次说我有小学妹什么的，我只是不想让你知道的时候不明事实，不想你生气，可是你这样，让我怎么相信你？你们在一起一年多，和我在一起就半年，所以，真的，挺失望的，最后原谅你一次，希望，以后我们都能好好的，希望能平平淡淡的过完余生，我觉得自己以前是足够信任你的，就算你不给我看你的手机 ，不告诉我你的密码，我也只是觉得，你和你朋友之间有什么我不太适合知道的小秘密，真的挺失落的，何怡然，最后一次，希望不要辜负了我的期待，今天开了这个博文，希望以后里面能够充满开心快乐的事，希望这是我们之间的最后一件不愉快。何怡然，我爱你，一辈子，你若不离，我定不弃，以后，我们好好地在一起。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019 fjut校赛 J(kmp|exkmp|ntt)]]></title>
    <url>%2F2019%2F05%2F13%2F2019-fjut%E6%A0%A1%E8%B5%9B-J-kmp-exkmp-ntt%2F</url>
    <content type="text"><![CDATA[链接第六集，想不到你这个浓眉大眼的都叛变革命了 题意给你一个母串和子串，如果子串改变一个字符能匹配母串，则输出yes，否者输出no 题解方法很多，大佬用的ntt和exkmp，菜鸡的我用的kmp，对母串每个位置分别求个前缀最长能匹配的子串位置，然后存下来，然后对它跑后缀，查在它前面两个的位置匹配的前缀的位置，如果前缀加后缀和加1（容错的1个）等于m（子串长度），则ok，后面就是细节了，因为匹配是最长，可能会出现循环节多了的情况，比如abcabc我们匹配到了abcabc,但是只需要abc，所以长度还得减去循环节，查看是否相等，还有如果匹配长度等于m-1并且后面还有字符则一定也可以，并且如果完全匹配也可以 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;string.h&gt;#include&lt;stdio.h&gt;int flag;int n,m,next[1000005],next2[1000005];char a[1000005],b[1000005];char aa[1000005],bb[1000005];int ab[1000005];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j]; next[i+1]=j+1; &#125;&#125;void Getnext2()&#123; next2[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;bb[i]!=bb[j]) j=next2[j]; next2[i+1]=j+1; &#125;&#125;void KMP()&#123; for(int i=0,j=0;i&lt;n;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=b[j]) j=next[j]; ab[i]=j; if(j+2==m&amp;&amp;i&lt;n-1||(j==-1&amp;&amp;j+2==m&amp;&amp;i&lt;n)) &#123; flag=1; &#125; if(j==m-1) flag=1; &#125;&#125;void KMP2()&#123; for(int i=0,j=0;i&lt;n;i++,j++) &#123; while(j!=-1&amp;&amp;aa[i]!=bb[j]) j=next2[j]; if(ab[n-i-3]+j+3==m&amp;&amp;n&gt;=i+3) &#123; flag=1; &#125; else if(ab[n-i-3]+j+3&gt;m&amp;&amp;n&gt;=i+3) &#123; if((ab[n-i-3]+1)%(ab[n-i-3]+1-next[ab[n-i-3]+1])==0&amp;&amp;(ab[n-i-3]+j+3-m)%((ab[n-i-3]+1-next[ab[n-i-3]+1]))==0) &#123; flag=1; &#125; if((j+1)%(j+1-next2[j+1])==0&amp;&amp;(ab[n-i-3]+j+3-m)%(j+1-next2[j+1])==0) &#123; flag=1; &#125; &#125; if(j+2==m&amp;&amp;i&lt;n-1||(j==-1&amp;&amp;j+2==m&amp;&amp;i&lt;n)) &#123; flag=1; &#125; &#125;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; flag=0; scanf(&quot;%s%s&quot;,a,b); //a-&gt;long b-&gt;short n=strlen(a);m=strlen(b); //if(m==1) //flag=1; Getnext(); KMP(); for(int i=0;i&lt;n;i++) &#123; aa[i]=a[n-i-1]; &#125; for(int i=0;i&lt;m;i++) &#123; bb[i]=b[m-i-1]; &#125; Getnext2(); KMP2(); if(m&gt;n) flag=0; if(flag==1) printf(&quot;YES\n&quot;); else printf(&quot;NO\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>fjut</category>
      </categories>
      <tags>
        <tag>-kmp -exkmp -ntt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ 4110 Strings in the Pocket (马拉车求回文串数量）]]></title>
    <url>%2F2019%2F04%2F29%2FZOJ-4110-Strings-in-the-Pocket-%E9%A9%AC%E6%8B%89%E8%BD%A6%E6%B1%82%E5%9B%9E%E6%96%87%E4%B8%B2%E6%95%B0%E9%87%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链接K- Strings in the Pocket 题意给你两个字符串ab，可以对a串中的子串进行翻转，问有多少对lr使得翻转后的a串等于b串 题解如果a串等于b串，则就是求a串中的回文串的数目（串的数目可能很多，得开longlong ）如果不一样，一定翻转第一个不相等和最后一个不相等的位置，然后判断翻转后是否相等，然后两边看能不能加特判l==r 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;char a[2000005],b[2000005],s_new[5000005];int p[5000005]; int init()&#123; int len=strlen(a),j=2; s_new[0]=&apos;$&apos;,s_new[1]=&apos;#&apos;; for(int i=0;i&lt;len;i++)&#123; s_new[j++]=a[i]; s_new[j++]=&apos;#&apos;; &#125; s_new[j]=0; return j;&#125;long long int manacher()&#123; long long int res=0; int len=init(),mx=0,id; for(int i=0;i&lt;len;i++)&#123; if(mx&gt;i)p[i]=min(p[2*id-i],mx-i); else p[i]=1; while(s_new[i-p[i]]==s_new[i+p[i]])p[i]++; if(mx&lt;i+p[i])mx=i+p[i],id=i; res+=p[i]/2; &#125; return res;&#125;int main()&#123; int i,j,m,n; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot; %s %s&quot;,a,b); n=strlen(a); int flag=-1,maxx=0; for(i=0;i&lt;n;i++) &#123; if(a[i]!=b[i]&amp;&amp;flag==-1) &#123; flag=i; &#125; if(a[i]!=b[i]) &#123; maxx=i; &#125; &#125; if(flag==-1) &#123; long long int cnt=manacher();//除以2是因为这里的字符串之间插入了‘#’ printf(&quot;%lld\n&quot;,cnt); &#125; else &#123; int cnt=1,jj; for(j=flag-1,jj=maxx+1;j&gt;=0,jj&lt;n;j--,jj++) &#123; if(a[j]!=a[jj]||j&lt;0||jj&gt;=n) break; else cnt++; &#125; if(maxx==flag) cnt=0; else &#123; int k; for(j=flag,k=maxx;j&lt;=maxx;j++,k--) &#123; if(a[j]!=b[k]) break; &#125; if(j&lt;=maxx) cnt=0; &#125; printf(&quot;%d\n&quot;,cnt); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>zoj</category>
      </categories>
      <tags>
        <tag>浙江省省赛</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sort的使用]]></title>
    <url>%2F2019%2F01%2F31%2Fsort%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[C++ 中sort 函数及 cmp 自定义规则的使用需要用到的头文件12#include&lt;algorithm&gt;using namespace std; 需要传两到三个参数，数据类型不限，只要是内定义了大小比较符，我们可以只传两个参数（区间首地址，区间尾地址的下一个地址）例如sort(a,a+n),对从a[0]到a[n-1]的数据进行从小到大的排序，如果想要改变排序方式或者对内部未定义大小比较符的进行排序，我们需要再传个比较函数cmp进去。，例如：12345678bool cmp(node x,node y)&#123; if(x.a!=y.a) return x.a if(x.b!=y.b) return x.b&gt;y.b; return return x.c&gt;y.c;&#125; sort(arr,arr+n,cmp); 先按a值升序排列，如果a值相同，再按b值降序排列，如果b还相同，就按c降序排列。]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Palindrome (Manacher)]]></title>
    <url>%2F2019%2F01%2F30%2FPalindrome-Manacher%2F</url>
    <content type="text"><![CDATA[链接A - Palindrome 题意输出最长的子回文串的长度 题解马拉车模板题 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int Manacher(string s) &#123; // Insert &apos;#&apos; string t = &quot;$#&quot;; for (int i = 0; i &lt; s.size(); ++i) &#123; t += s[i]; t += &quot;#&quot;; &#125; // Process t vector&lt;int&gt; p(t.size(), 0); int mx = 0, id = 0, resLen = 0, resCenter = 0; for (int i = 1; i &lt; t.size(); ++i) &#123; p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1; while (t[i + p[i]] == t[i - p[i]]) ++p[i]; if (mx &lt; i + p[i]) &#123; mx = i + p[i]; id = i; &#125; if (resLen &lt; p[i]) &#123; resLen = p[i]; resCenter = i; &#125; &#125; return resLen - 1;&#125;int main() &#123; string s1; int k=0; while(1) &#123; k++; cin&gt;&gt;s1; if(s1[0]==&apos;E&apos;) break; else &#123; cout&lt;&lt;&quot;Case &quot;&lt;&lt;k&lt;&lt;&quot;: &quot;&lt;&lt;Manacher(s1)&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>VJ</category>
      </categories>
      <tags>
        <tag>Manacher</tag>
        <tag>VJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[E1. Array and Segments(暴力)]]></title>
    <url>%2F2019%2F01%2F28%2FE1-Array-and-Segments-%E6%9A%B4%E5%8A%9B-1%2F</url>
    <content type="text"><![CDATA[链接E1. Array and Segments (Easy version) 题意一串长为n的数串，m个区间，选择区间使得该区间的数减一，求最后修改完后数串(max-min)的最大值。 题解方法很多，e1是简单，直接暴力即可，对每一位都当做最大值来进行区间选择，我们知道如果使得（max-min)的值最大，则max越大，min越小越好，由于没有加的操作，所以我们只能间接让max最大，即当选定为max后，如果区间包含该位置则不选该区间，如果不包含，则选区间，因为他可能有两种情况，使min更小或者不影响结果。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;int a[1000005];int b[1000005];int l[1000005];int r[1000005];int main()&#123; int i,j,m,n,k,sum=0,minn=1000000,memi=1,memn=0,qum; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(i=1;i&lt;=m;i++) &#123; scanf(&quot;%d%d&quot;,&amp;l[i],&amp;r[i]); &#125; for(i=1;i&lt;=n;i++) &#123; qum=0; for(j=1;j&lt;=n;j++) b[j]=a[j]; for(j=1;j&lt;=m;j++) &#123; if(l[j]&lt;=i&amp;&amp;r[j]&gt;=i) &#123; &#125; else &#123; qum++; for(k=l[j];k&lt;=r[j];k++) b[k]--; &#125; &#125; minn=b[1]; for(j=2;j&lt;=n;j++) &#123; if(b[j]&lt;minn) minn=b[j]; &#125; if(sum&lt;a[i]-minn) &#123; memn=qum; memi=i; sum=a[i]-minn; &#125; &#125; printf(&quot;%d\n&quot;,sum); printf(&quot;%d\n&quot;,memn); int dum=0; for(i=1;i&lt;=m;i++) &#123; if(l[i]&lt;=memi&amp;&amp;r[i]&gt;=memi) &#123; &#125; else &#123; dum++; if(dum==memn) printf(&quot;%d\n&quot;,i); else printf(&quot;%d &quot;,i); &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[D. Game with modulo(交互，二分)]]></title>
    <url>%2F2019%2F01%2F28%2FD-Game-with-modulo-%E4%BA%A4%E4%BA%92%EF%BC%8C%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[链接D. Game with modulo 题意给你一个a，你可以输入x,y进行询问，返回”x”, 如果 (x mod a)≥(y mod a)，返回”y”,如果(x mod a)&lt;(y mod a)，最多60次询问，请设计一个方案求出a的值。 题解分块二分，首先0到1询问，如果返回为x则证明a为1，然后询问（1，2）（2，4）（4，8）……（1e9,2e9)，如果返回为x则证明a在该区间，对区间进行二分查询。 最开始想的是直接1到2e9进行二分，发现会超过60次。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;long long int a[50],l,r,m;char f[100];int main()&#123; int i,j,n; a[0]=0; a[1]=1; for(i=2;i&lt;=32;i++) &#123; a[i]=a[i-1]*2; &#125; while(scanf(&quot; %s&quot;,f)!=EOF) &#123; if(f[0]!=&apos;s&apos;) break; char c; for(i=0;i&lt;=30;i++) &#123; printf(&quot;? %lld %lld\n&quot;,a[i],a[i+1]); fflush(stdout); scanf(&quot; %c&quot;,&amp;c); if(c==&apos;x&apos;) break; &#125; if(a[i]==0) &#123; printf(&quot;! 1\n&quot;); fflush(stdout); &#125; else &#123; l=a[i]+1,r=a[i+1]; while(l&lt;r) &#123; m=(l+r)/2; printf(&quot;? %lld %lld\n&quot;,m,l-1); fflush(stdout); scanf(&quot; %c&quot;,&amp;c); if(c==&apos;x&apos;) l=m+1; else r=m; &#125; printf(&quot;! %lld\n&quot;,l); fflush(stdout); &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>二分</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[acm模板]]></title>
    <url>%2F2019%2F01%2F27%2Facm%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[其他位运算1234567891011121314151617#include&lt;iostream&gt;using namespace std;int main()&#123; int n=15,m=8;//1111，1000 unsigned int x=8,y=7; cout&lt;&lt;__builtin_popcount(n)&lt;&lt;endl;//判断n中有几个1 cout&lt;&lt;__builtin_parity(n)&lt;&lt;endl;//判断n中1的个数的奇偶性,奇数输出1，偶数输出0 cout&lt;&lt;__builtin_parity(m)&lt;&lt;endl; cout&lt;&lt;__builtin_ffs(n)&lt;&lt;endl;//判断n的二进制末尾最后一个1的位置 cout&lt;&lt;__builtin_ffs(m)&lt;&lt;endl; cout&lt;&lt;__builtin_ctzll(n)&lt;&lt;endl;//判断n的二进制末尾后面0的个数，当n为0时，和n的类型有关 cout&lt;&lt;__builtin_ctz(m)&lt;&lt;endl; cout&lt;&lt;__builtin_clz(x)&lt;&lt;endl;//前导0的个数(为32位） cout&lt;&lt;__builtin_clz(y)&lt;&lt;endl; return 0; &#125; 博弈nim博弈123456789101112131415//读入n，表示有从物品数分别1到n的n堆物品，假设n个数存在数组f[]中，当n很大的时候异或和 int xor_n(int n)//从1到n的异或和&#123; int t = n &amp; 3; if (t &amp; 1) return t / 2 ^ 1; return t / 2 ^ n;&#125;int Nim_Game(int n)//有必胜策略返回1，nim博弈 &#123; int flag=0; for(int i=1;i&lt;=n;i++) flag^=xor_n(f[i]); if(flag) return 1; return 0;&#125; sg函数sg(x)=sg(mem(y));y为x的后继，例如x的后继为a,b,c，那么SG(x)=mex{SG(a),SG(b),SG(c)}，当sg(x)==0时,代表当前点为必败.对于多种状态，sg（x)=sg(x1)^sg(x2)^….; sg打表1234567891011121314151617181920212223//f[]：可以取走的石子个数//sg[]:0~n的SG函数值//hash[]:mex&#123;&#125;int f[N],sg[N],hash[N]; void getSG(int n)&#123; int i,j; memset(sg,0,sizeof(sg)); for(i=1;i&lt;=n;i++) &#123; memset(hash,0,sizeof(hash)); for(j=1;f[j]&lt;=i;j++) hash[sg[i-f[j]]]=1;//标记，f[j]表示能够取的，i-f[i]表示他的后继 for(j=0;j&lt;=n;j++) //求mes&#123;&#125;中未出现的最小的非负整数 &#123; if(hash[j]==0) &#123; sg[i]=j; break; &#125; &#125; &#125;&#125; dfs123456789101112131415161718192021222324252627//注意 S数组要按从小到大排序 SG函数要初始化为-1 对于每个集合只需初始化1遍//n是集合s的大小 S[i]是定义的特殊取法规则的数组int s[110],sg[10010],n;int SG_dfs(int x)&#123; int i; if(sg[x]!=-1) return sg[x]; bool vis[110]; memset(vis,0,sizeof(vis)); for(i=0;i&lt;n;i++) &#123; if(x&gt;=s[i]) &#123; SG_dfs(x-s[i]); vis[sg[x-s[i]]]=1; &#125; &#125; int e; for(i=0;;i++) if(!vis[i]) &#123; e=i; break; &#125; return sg[x]=e;&#125; 数据结构线段树线段树的单点修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const int maxn=1e6+5;int a[maxn]; //存每个数的值struct node&#123; int sum; int ll,rr;&#125;tree[maxn*4];void Pushup(int id) //区间合并&#123; tree[id].sum=tree[id*2].sum+tree[id*2+1].sum;&#125;void Pushdown() //区间下放，进行区间修改的时候用到&#123;&#125;void Build(int id,int ll,int rr) //建树&#123; tree[id].ll=ll; tree[id].rr=rr; if(ll==rr) &#123; tree[id].sum=a[ll]; return; &#125; int mid=(ll+rr)/2; //mid=ll+rr&gt;&gt;1; Build(id*2,ll,mid); Build(id*2+1,mid+1,rr); //Build(id&lt;&lt;1,ll,mid); //Build(id&lt;&lt;1|1,mid+1,rr); Pushup(id);&#125;void Update(int id,int x,int y) //修改&#123; if(tree[id].ll==tree[id].rr) &#123; tree[id].sum=y; return; &#125; int mid=(tree[id].ll+tree[id].rr)/2; if(x&lt;=mid) Update(id*2,x,y); else Update(id*2+1,x,y); Pushup(id);&#125;int Query(int id,int x,int y) //查询&#123; if(x&lt;=tree[id].ll&amp;&amp;tree[id].rr&lt;=y)//到头的情况 return tree[id].sum; int mid=(tree[id].ll+tree[id].rr)/2; if(y&lt;=mid) //只需要访问左边 return Query(id*2,x,y); else if(x&gt;=mid+1) return Query(id*2+1,x,y); else return Query(id*2,x,y)+Query(id*2+1,x,y);&#125; 线段树的区间修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const int maxn=1e6+5;long long int a[maxn];long long int lazy[maxn*4]; //存每个数的值struct node&#123; long long int sum; long long int ll,rr;&#125;tree[maxn*4];void Pushup(int id) //区间合并&#123; tree[id].sum=tree[id*2].sum+tree[id*2+1].sum;&#125;void Pushdown(int id) //区间下放，进行区间修改的时候用到&#123; if(lazy[id]) &#123; tree[id*2].sum+=lazy[id]*(tree[id*2].rr-tree[id*2].ll+1); tree[id*2+1].sum+=lazy[id]*(tree[id*2+1].rr-tree[id*2+1].ll+1); lazy[id*2]+=lazy[id]; lazy[id*2+1]+=lazy[id]; lazy[id]=0; &#125;&#125;void Build(int id,int ll,int rr) //建树&#123; lazy[id]=0; tree[id].ll=ll; tree[id].rr=rr; if(ll==rr) &#123; tree[id].sum=a[ll]; return; &#125; int mid=(ll+rr)/2; //mid=ll+rr&gt;&gt;1; //Build(ltree); //Build(rtree); Build(id&lt;&lt;1,ll,mid); Build(id&lt;&lt;1|1,mid+1,rr); Pushup(id);&#125;void Update(int id,int x,int y,int z) //修改&#123; if(x&lt;=tree[id].ll&amp;&amp;tree[id].rr&lt;=y) &#123; tree[id].sum+=z*(tree[id].rr-tree[id].ll+1); lazy[id]+=z; return; &#125; int mid=(tree[id].ll+tree[id].rr)/2; Pushdown(id); if(y&lt;=mid) Update(id*2,x,y,z); else if(x&gt;=mid+1) Update(id*2+1,x,y,z); else &#123; Update(id*2,x,y,z); Update(id*2+1,x,y,z); &#125; Pushup(id);&#125;long long int Query(int id,int x,int y) //查询&#123; if(x&lt;=tree[id].ll&amp;&amp;tree[id].rr&lt;=y)//到头的情况 return tree[id].sum; int mid=(tree[id].ll+tree[id].rr)/2; Pushdown(id); if(y&lt;=mid) //只需要访问左边 return Query(id*2,x,y); else if(x&gt;=mid+1) return Query(id*2+1,x,y); else return Query(id*2,x,y)+Query(id*2+1,x,y);&#125; 主席树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100000 + 5;int a[N], b[N], rt[N * 20], ls[N * 20], rs[N * 20], sum[N * 20];int n, k, tot, sz, ql, qr, x, q, T;void Build(int&amp; o, int l, int r)&#123; o = ++ tot; sum[o] = 0; if(l == r) return; int m = (l + r) &gt;&gt; 1; Build(ls[o], l, m); Build(rs[o], m + 1, r);&#125;void update(int&amp; o, int l, int r, int last, int p)&#123; o = ++ tot; ls[o] = ls[last]; rs[o] = rs[last]; sum[o] = sum[last] + 1; if(l == r) return; int m = (l + r) &gt;&gt; 1; if(p &lt;= m) update(ls[o], l, m, ls[last], p); else update(rs[o], m + 1, r, rs[last], p);&#125;int query(int ss, int tt, int l, int r, int k)&#123; if(l == r) return l; int m = (l + r) &gt;&gt; 1; int cnt = sum[ls[tt]] - sum[ls[ss]]; if(k &lt;= cnt) return query(ls[ss], ls[tt], l, m, k); else return query(rs[ss], rs[tt], m + 1, r, k - cnt);&#125;void work()&#123; scanf(&quot;%d%d%d&quot;, &amp;ql, &amp;qr, &amp;x); int ans = query(rt[ql - 1], rt[qr], 1, sz, x); printf(&quot;%d\n&quot;, b[ans]);&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;T); while(T--)&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, a + i), b[i] = a[i]; sort(b + 1, b + n + 1); sz = unique(b + 1, b + n + 1) - (b + 1); tot = 0; Build(rt[0],1, sz); //for(int i = 0; i &lt;= 4 * n; i ++)printf(&quot;%d,rt = %d,ls = %d, rs = %d, sum = %d\n&quot;, i, rt[i], ls[i], rs[i], sum[i]); for(int i = 1; i &lt;= n; i ++)a[i] = lower_bound(b + 1, b + sz + 1, a[i]) - b; for(int i = 1; i &lt;= n; i ++)update(rt[i], 1, sz, rt[i - 1], a[i]); //for(int i = 0; i &lt;= 5 * n; i ++)printf(&quot;%d,rt = %d,ls = %d, rs = %d, sum = %d\n&quot;, i, rt[i], ls[i], rs[i], sum[i]); while(q --)work(); &#125; return 0;&#125; 树状数组123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;int tree[1000000],n;int lowbit(int x)&#123; return x&amp;(-x);&#125;int Query(int x)//查询x项的前缀和 ； &#123; int res=0; while(x) &#123; res+=tree[x]; x-=lowbit(x); &#125; return res;&#125;void Add(int x,int v)//在x位加v； &#123; while(x&lt;=n) &#123; tree[x]+=v; x+=lowbit(x); &#125;&#125;int main()&#123; int a[100000],x; scanf(&quot;%d %d&quot;,&amp;n,&amp;x); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++) &#123; Add(i,a[i]);//树状数组的预处理，初始化 &#125; printf(&quot;%d\n&quot;,Query(x)); return 0;&#125; st表1234567891011121314void Init()&#123; for(int i = 0; i &lt; n; i++) d[i][0] = a[i]; for(int j = 1; (1&lt;&lt;j) &lt;= n; j++) for(int i = 0; i+(1&lt;&lt;j) &lt;= n; i++) d[i][j] = min(d[i][j-1], d[i+(1&lt;&lt;(j-1))][j-1]);&#125;int RMQ(int l, int r)&#123; int k = 0; while((1&lt;&lt;k) &lt;= r-l+1)k++; k--; return min(d[l][k], d[r-(1&lt;&lt;k)+1][k]);&#125; 字符串kmp12345678910111213141516171819202122232425262728#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[100001];char a[100001],b[100001];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j]; next[i+1]=j+1; &#125;&#125;void KMP()&#123; for(int i=0,j=0;i&lt;n;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=b[j]) j=next[j]; if(j==m-1) printf(&quot;%d\n&quot;,i-j+1); &#125;&#125;int main()&#123; scanf(&quot;%s%s&quot;,a,b); //a-&gt;long b-&gt;short n=strlen(a);m=strlen(b); Getnext(); KMP();&#125; ac自动机12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;const int N=500005;int T,n,tot,end[N],fail[N],son[N][26];char s[N*2];std::queue&lt;int&gt; Q;void init(int x)&#123; end[x]=0; for(int i=0;i&lt;26;i++) son[x][i]=0;&#125;void Add()&#123; scanf(&quot;%s&quot;,s); int len=strlen(s),pre=0; for(int i=0;i&lt;len;i++) &#123; if(!son[pre][s[i]-&apos;a&apos;]) init(son[pre][s[i]-&apos;a&apos;]=++tot); pre=son[pre][s[i]-&apos;a&apos;]; &#125; end[pre]++;&#125;void Build()&#123; Q.push(0); while(!Q.empty()) &#123; int x=Q.front();Q.pop(); for(int i=0;i&lt;26;i++) &#123; if(son[x][i]) &#123; Q.push(son[x][i]); fail[son[x][i]]=x?son[fail[x]][i]:0; &#125; else son[x][i]=x?son[fail[x]][i]:0; &#125; &#125;&#125;int Calc()&#123; scanf(&quot;%s&quot;,s); int len=strlen(s),pre=0,ans=0; for(int i=0;i&lt;len;i++) &#123; pre=son[pre][s[i]-&apos;a&apos;]; for(int j=pre;j;j=fail[j]) ans+=end[j],end[j]=0; &#125; return ans;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; init(tot=0); for(scanf(&quot;%d&quot;,&amp;n);n;n--) Add(); Build(); printf(&quot;%d\n&quot;,Calc()); &#125;&#125; Manacher推荐博客：Manacher’s Algorithm 马拉车算法1234567891011121314151617181920212223242526272829303132333435363738#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string Manacher(string s) &#123; // Insert &apos;#&apos; string t = &quot;$#&quot;;//在头插入$# for (int i = 0; i &lt; s.size(); ++i) &#123; t += s[i]; t += &quot;#&quot;;//s[i]的每个字母前后都插入# &#125; // Process t vector&lt;int&gt; p(t.size(), 0); int mx = 0, id = 0, resLen = 0, resCenter = 0; for (int i = 1; i &lt; t.size(); ++i) &#123;//两个指针mx,resLen，两个保存变量id,resCenter; resLen代表最长的回文串中心的半径，i代表最长的回文串 p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1;//p[i]存以该点为中心，回文串的半径（包含该点）(例$#1#2#2#1)最中间的#半径为4 //2*id-i是i关于id的对称点，如果mx-i&gt;p[j]，则为12321，id为3，mx为3，i为4，j为2，p[j]=1,p[i]也应该为1，i，j在id包围中且j的回文串也在id的包围中，所以i的回文串应该和j一样 //如果mx-i&lt;p[j]，也就是超出了id的包含范围，这个时候p[i]只能为mx-i，剩下的只能一个一个的匹配了 while (t[i + p[i]] == t[i - p[i]]) ++p[i];//回文串处理 if (mx &lt; i + p[i]) &#123; mx = i + p[i];//mx是回文串所能到达的最右边的位置 id = i; &#125; if (resLen &lt; p[i]) &#123; resLen = p[i]; resCenter = i; &#125; &#125; return s.substr((resCenter - resLen) / 2, resLen - 1);//返回最大的回文串，(resCenter - resLen) / 2为开始位置 ， resLen - 1为长度（包含了#） &#125;int main() &#123; string s1 = &quot;12212&quot;; cout &lt;&lt; Manacher(s1) &lt;&lt; endl; string s2 = &quot;122122&quot;; cout &lt;&lt; Manacher(s2) &lt;&lt; endl; string s = &quot;waabwswfd&quot;; cout &lt;&lt; Manacher(s) &lt;&lt; endl;&#125; 数学素数筛1234567891011for(int i=2;i&lt;=n;i++)&#123; if(!prime[i]) isprime[++num]=i; for(int j=1;j&lt;=num&amp;&amp;i*isprime[j]&lt;=n;j++) &#123; prime[i*isprime[j]]=1; if(i%isprime[j]==0) break; &#125; &#125; 数论阶乘因式分解（给你n,m，问n的阶乘中有多少个因子为m）12345while(n)&#123; sum+=n/m; n/=m;&#125; 连分数逼近法 3.245 的连分数是 [3; 4, 12, 4] 3+1/(4+(1/(12+1/4)))1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define ling 1e-8int main()&#123; double s; int a[1000]; //或者scanf(&quot;%d%d&quot;,&amp;a,&amp;b); 令s=a*1.0/(b*1.0); while (scanf(&quot;%lf&quot;,&amp;s)==1) &#123; int i=0; while (fabs(s)&gt;ling) &#123; a[i++]=(int)s; s=1/(s-(int)s); &#125; for (int j=0;j&lt;i-1;j++) cout&lt;&lt;a[j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; return 0;&#125; 欧拉函数欧拉函数是小于x的整数中与x互质的数的个数欧拉函数的几个性质1.对于质数p，φ(p)=p−1φ(p)=p−1 φ(p)=p-1φ(p)=p−1。2.若p为质数，n=pkn=pk n=p^kn=pk，则φ(n)φ(n) φ(n)φ(n)=pkpk p^kpk-pk−1pk−1 p^{k-1}pk−1。3.欧拉函数是积性函数，但不是完全积性函数。若m,n互质，则φ(m∗n)=φ(m)∗φ(n)φ(m∗n)=φ(m)∗φ(n) φ(mn)=φ(m)φ(n)φ(m∗n)=φ(m)∗φ(n)。特殊的，当m=2，n为奇数时，φ(2n)=φ(n)。4.当n&gt;2时，φ(n)是偶数。5.小于n的数中，与n互质的数的总和为：φ(n) n / 2 (n&gt;1)。6.n=∑d∣n φ(d)n=∑d∣n φ(d)即n的因数（包括1和它自己）的欧拉函数之和等于n。 单个求解欧拉函数12345678int eurlar(int x)&#123; int ret=x; for (int i=2;i&lt;=sqrt(x)&amp;&amp;x&gt;1;i++) if (x%i==0) &#123;ret=ret/i*(i-1); while (x%i==0) x/=i;&#125; if (x&gt;1) ret=ret/x*(x-1); return ret;&#125; 埃拉托斯特尼筛求欧拉函数(o(n)lnln)1234567891011121314void euler(int n)//phi[i]代表i的欧拉值，&#123; for (int i=1;i&lt;=n;i++) phi[i]=i; for (int i=2;i&lt;=n;i++) &#123; if (phi[i]==i)//这代表i是质数 &#123; for (int j=i;j&lt;=n;j+=i) &#123; phi[j]=phi[j]/i*(i-1);//把i的倍数更新掉 &#125; &#125; &#125;&#125; 欧拉筛求欧拉函数（o(n)）1234567891011121314151617181920212223void euler(int n)//flag[i]代表i是否为质数，prime存的质数，phi[i]代表i的欧拉值&#123; int num=0; phi[1]=1;//1要特判 for (int i=2;i&lt;=n;i++) &#123; if (flag[i]==0)//这代表i是质数 &#123; prime[++num]=i; phi[i]=i-1; &#125; for (int j=1;j&lt;=num&amp;&amp;prime[j]*i&lt;=n;j++)//经典的欧拉筛写法 &#123; flag[i*prime[j]]=1;//先把这个合数标记掉 if (i%prime[j]==0) &#123; phi[i*prime[j]]=phi[i]*prime[j];//若prime[j]是i的质因子，则根据计算公式，i已经包括i*prime[j]的所有质因子 break;//经典欧拉筛的核心语句，这样能保证每个数只会被自己最小的因子筛掉一次 &#125; else phi[i*prime[j]]=phi[i]*phi[prime[j]];//利用了欧拉函数是个积性函数的性质 &#125; &#125;&#125; 中国剩余定理中国剩余定理求x的最小非负整数解 //求M%A=a,M%B=b,…中的M，其中A,B,C…互质1234567891011121314int CRT(int a[],int m[],int n)&#123; int M = 1; int ans = 0; for(int i=1; i&lt;=n; i++) M *= m[i]; for(int i=1; i&lt;=n; i++)&#123; int x, y; int Mi = M / m[i]; ex_gcd(Mi, m[i], x, y); ans = (ans + Mi * x * a[i]) % M; &#125; if(ans &lt; 0) ans += M; return ans; &#125; 扩展中国剩余定理//求M%A=a,M%B=b,…中的M，其中A,B,C…不互质12345678910111213141516171819202122232425262728293031bool merge(LL a1, LL m1, LL a2, LL m2, LL &amp;a3, LL &amp;m3) &#123; LL d = gcd(m1, m2); LL c = a2 - a1; if(c % d) return false; c = (c % m2 + m2) % m2; m1 /= d; m2 /= d; c /= d; c *= Inv(m1, m2);//Inv为乘法逆元，数论常用内容——欧几里得算法与扩展欧几里得算法 c %= m2; c *= m1 * d; c += a1; m3 = m1 * m2 * d; a3 = (c % m3 + m3) % m3; return true; &#125; LL CRT(LL a[], LL m[], int n) &#123; LL a1 = a[1]; LL m1 = m[1]; for(int i=2; i&lt;=n; i++) &#123; LL a2 = a[i]; LL m2 = m[i]; LL m3, a3; if(!merge(a1, m1, a2, m2, a3, m3)) return -1; a1 = a3; m1 = m3; &#125; return (a1 % m1 + m1) % m1; &#125; 大素数 米勒拉宾素数测试12345678910111213141516171819202122232425262728293031323334353637383940ll quick_pow(ll a,ll b,ll r)//快速幂 &#123; ll ans = 1; while(b) &#123; if(b&amp;1)ans=(ans*a)%r; a = (a*a)%r; b&gt;&gt;=1; &#125; return ans;&#125;bool Miller_Rabbin(int n,int a)//米勒拉宾素数测试 &#123; int r=0,s=n-1,j; if(!(n%a)) return false; while(!(s&amp;1))&#123; s&gt;&gt;=1; r++; &#125; ll k=qpow(a,s,n); if(k==1) return true; for(j=0;j&lt;r;j++,k=k*k%n) if(k==n-1) return true; return false;&#125;bool IsPrime(int n)//判断是否是素数 &#123; int tab[]=&#123;2,3,5,7&#125;; for(int i=0;i&lt;4;i++) &#123; if(n==tab[i]) return true; if(!Miller_Rabbin(n,tab[i])) return false; &#125; return true;&#125; 佩尔方程（x^2-dy^2=1)连分数法12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a[20000];bool pell_minimum_solution(ll n,ll &amp;x0,ll &amp;y0)&#123;//求PELL方程最小整数解 ll m=(ll)sqrt((double)n);//M是N的平方根向下取整 if(m*m==n)return false;//当n是完全平方数则佩尔方程无解（不讨论正负一，零） //下面是把N用连分数形式存，B,C,TMP（即AI）的递推见解释以22为例参考 int i=0; //连分数的数位 a[i++]=m; //A0位整数部分m=4 ll b=m,c=1; //B=4即整数部分位,C=1即求RN时的分母 double sq=sqrt(n);//SQ是N的高精度根,相当于r0 double tmp;//tp在下面的循环就是rn do&#123; c=(n-b*b)/c; tmp=(sq+b)/c; a[i++]=(ll)(floor(tmp)); b=a[i-1]*c-b; //printf(&quot;%lld %lld %lld\n&quot;,a[i-1],b,c); &#125;while(a[i-1]!=2*a[0]);//当有一位等于整数两倍就结束 //下面就是要把连分数形式化成分子分母的形式，求PQ两个值 ll p=1,q=0; for(int j=i-2;j&gt;=0;j--)&#123; ll t=p; p=q+p*a[j]; q=t; //printf(&quot;a[%d]=%lld %lld %lld\n&quot;,j,a[j],p,q); &#125; if((i-1)%2==0)&#123;x0=p;y0=q;&#125;//如果I是奇数，X0与Y0都是0 else&#123;x0=2*p*p+1;y0=2*p*q;&#125;//如果I是偶数，X0是两倍P方+1，y0是两倍PQ return true;&#125;int main()&#123; ll n,x,y; while(~scanf(&quot;%lld&quot;,&amp;n))&#123; if(pell_minimum_solution(n,x,y))&#123;//输入N求X,Y的值，有解就输出 printf(&quot;x=%lld y=%lld\t&quot;,x,y);//x,y printf(&quot;%lld^2-%lld*%lld^2=1\t&quot;,x,n,y);//x^2-n*y^2=1 printf(&quot;%lld-%lld=1\n&quot;,x*x,n*y*y);//(x^2)-(n*y^2)=1 &#125; &#125; return 0;&#125; 暴力法1234567891011121314typedef long long ll;int x,y;void mysearch()&#123; y=1; while(1)&#123; x=(ll)sqrt(d*y*y+1); if(x*x-d*y*y==1)&#123; break; &#125; y++; &#125;&#125; 快速幂1234567int power(int a,int b,int P)&#123; int re=1; for(;b;b&gt;&gt;=1,a=(long long)a*a%P) if(b&amp;1) re=(long long)re*a%P; return re;&#125; exgcd12345678910111213141516171819#include &lt;cstdio&gt;using namespace std;int a,b,c,d,x,y;void exgcd(int a,int b,int &amp;d,int &amp;x,int &amp;y)&#123; if(!b) d=a,x=1,y=0; else exgcd(b,a%b,d,y,x),y-=a/b*x;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); exgcd(a,b,d,x,y); if(!(c%d)) &#123; x*=c/d;y*=c/d;a/=d;b/=d; for(int k=-2;k&lt;=2;k++) printf(&quot;%d %d\n&quot;,x+k*b,y-k*a); &#125;&#125; BM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1000000007;ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;ll _,n;namespace linear_seq&#123; const int N=10010; ll res[N],base[N],_c[N],_md[N]; vector&lt;ll&gt; Md; void mul(ll *a,ll *b,int k) &#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; &#125; int solve(ll n,VI a,VI b) &#123; ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt;p&gt;=0;p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (int i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans; &#125; VI BM(VI s) &#123; VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; int gao(VI a,ll n)&#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c))); &#125;&#125;;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld&quot;,&amp;n); vector&lt;int&gt;v; v.push_back(1); //至少8项，越多越好。 v.push_back(5); v.push_back(15); v.push_back(35); v.push_back(70); v.push_back(126); v.push_back(210); v.push_back(330); v.push_back(495); v.push_back(715); printf(&quot;%lld\n&quot;,linear_seq::gao(v,n-1)%mod); &#125;&#125; 组合数学计算数学凸包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;const int N=1e5+5;const double eps=1e-6;int n,top;double len,S;struct Point &#123; double x,y; &#125; a[N],b[N];double dis(Point x,Point y)&#123; return sqrt((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y));&#125;double Cross(Point x,Point y,Point z)&#123; return (x.x-z.x)*(y.y-z.y)-(x.y-z.y)*(y.x-z.x);&#125;double Cross(Point x,Point y)&#123; return x.x*y.y-x.y*y.x;&#125;bool cmp(const Point &amp;x,const Point &amp;y)&#123; double t=Cross(x,y,a[1]);return abs(t)&gt;eps?t&gt;0:dis(a[1],x)&lt;dis(a[1],y);&#125;inline void Graham()&#123; int t=1; for(int i=2;i&lt;=n;i++) if(a[i].x&lt;a[t].x||(a[i].x==a[t].x&amp;&amp;a[i].y&lt;a[t].y)) t=i; if(t!=1) std::swap(a[t],a[1]); std::sort(a+2,a+n+1,cmp); for(int i=1;i&lt;=n;i++) &#123; while(top&gt;1&amp;&amp;Cross(a[i],b[top],b[top-1])&gt;=0) top--; b[++top]=a[i]; &#125; b[top+1]=b[1];&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;a[i].x,&amp;a[i].y); Graham();//求凸包的点 for(int i=1;i&lt;=top;i++) len+=dis(b[i],b[i+1]); printf(&quot;L: %.8lf\n&quot;,len);//求凸包的长度 for(int i=1;i&lt;=top;i++) S+=Cross(b[i],b[i+1]); printf(&quot;S: %.8lf\n&quot;,S/2);//求凸包的面积 &#125; 点旋转123假设对图片上任意点(x,y)，绕一个坐标点(rx0,ry0)逆时针旋转a角度后的新的坐标设为(x0, y0)，有公式： x0= (x - rx0)*cos(a) - (y - ry0)*sin(a) + rx0 ; y0= (x - rx0)*sin(a) + (y - ry0)*cos(a) + ry0 ; 图论最短路Floyd算法，多源无负权12345678910111213141516//通过邻接矩阵跑出所有点之间的最短路,时间复杂度O(n^3),空间复杂度O(n^2)//d[i][j]表示i到j的最短路径长度,初始化：d[i][i]=0,点到点有路按正常权值初始化,其余INFint mp[n][n];int d[n][n];void Floyd()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) d[i][j]=mp[i][j]; for(int k=1;k&lt;=n;k++) //枚举以k为中间点的所有点的最短路 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);&#125; Dijkstra算法,单源无负权12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//适用于边权为正的情况,单源最短路问题//时间复杂度为O(V*V+E)//算法思路:设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，//第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，//以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了）//不断的维护一个dis数组，最后得到的dis数组中dis[i]就是源点到图中节点i的最短路径的长度//记录vis数组判断当前点是否访问过int mp[n][n];int dis[n];int vis[n];void init()&#123; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(i==j) mp[i][j]=0; else mp[i][j]=INF; &#125; &#125;&#125;int djs(int st,int ed)&#123; for(int i=1;i&lt;=n;i++) &#123; dis[i]=mp[st][i]; vis[i]=0; &#125; vis[st]=1; for(int i=1;i&lt;n;i++) //更新dis数组,起点不用更新了,所以是n-1次 &#123; int minn=INF; //更新最小距离点 int next=-1; //确定下一个点 for(int j=1;j&lt;=n;j++) &#123; if(vis[j]==0&amp;&amp;dis[j]&lt;minn) &#123; minn=dis[j]; next=j; &#125; &#125; if(next==-1) //当前已不存在点 continue; vis[next]=1; for(int j=1;j&lt;=n;j++) &#123; if(vis[j]==0) //vis[j]=1已为最短路径 dis[j]=min(dis[j],dis[next]+mp[next][j]); //以next为中间点进行松弛 &#125; &#125; return dis[ed]; //找到st到ed的最短路&#125; SPFA,Bellman-Ford的队列优化,玄学时间复杂度,O(E)-O(VE)之间123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//假设有一个点刚刚被优化了，我们可以很明显的发现，针对这条边，//也就只有这条边的出边上的终点才可以继续被优化，这就给了我们启示，//其实我们可以再维护一个队列，一个点如果被优化过了，那么就进队列，int mp[n][n];int n,m;int dis[n];int vis[n];void init()&#123; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(i==j) mp[i][j]=0; else mp[i][j]=INF; &#125; &#125;&#125;int spfa(int st,int ed)&#123; for(int i=1;i&lt;=n;i++) &#123; dis[i]=INF; vis[i]=0; &#125; dis[st]=0; queue&lt;int&gt;q; q.push(st); vis[st]=1; while(!q.empty()) &#123; int now=q.front(); q.pop(); vis[now]=0; for(int i=1;i&lt;=n;i++) &#123; if(dis[i]&gt;dis[now]+mp[now][i]) &#123; dis[i]=dis[now]+mp[now][i]; if(vis[i]==0) &#123; q.push(i); vis[i]=1; &#125; &#125; &#125; &#125; return dis[ed];&#125; 并查集1234567891011121314151617181920212223242526272829303132333435int par[MAX_N]; //父亲 int rank[MAX_N]; //树的高度//初始化n个元素void init(int n)&#123; for(int i = 0; i &lt; n; i++)&#123; par[i] = i; rank[i] = 0; &#125;&#125; //查询树的根int find(int x)&#123; if(par[x] == x) return x; else return par[x] = find(par[x]);&#125; //合并x和y所属的集合void unite(int x, int y)&#123; x = find(x); y = find(y); if(x == y) return; if(rank[x] &lt; rank[y]) par[x] = y; else par[y] = x; if(rank[x] == rank[y]) rank[x]++;&#125; //判断x和y是否属于同一个集合bool same(int x, int y)&#123; return find(x) == find(y);&#125;]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kunagbin专题一 kmp]]></title>
    <url>%2F2019%2F01%2F26%2Fkunagbin%E4%B8%93%E9%A2%98%E4%B8%80-kmp%2F</url>
    <content type="text"><![CDATA[A B C D E F G H I J K L M N O P √ √ √ √ √ √ √ √ √ √ A - Oulipo简单kmp板子题，求母串里有几个子串 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[1000001];long long int sum;char a[1000001],b[1000001];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j];//j取-1只是为了判断边界，就如果j为0的话会一直循环下去 next[i+1]=j+1;//匹配到第i+1个时，从第i个开始匹配，例如abcabcd 与 abcabce第3个匹配不上，但是前两个匹配得上 &#125;&#125;void KMP()&#123; for(int i=0,j=0;i&lt;n;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=b[j]) j=next[j]; if(j==m-1) sum++; &#125;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; sum=0; memset(next,0,sizeof(next)); scanf(&quot;%s%s&quot;,b,a); //a-&gt;long b-&gt;short n=strlen(a);m=strlen(b); Getnext(); KMP(); printf(&quot;%lld\n&quot;,sum); &#125; return 0;&#125; B - Number Sequence子字符串在母串的位置，板子题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[1000001];long long int sum;int a[1000001],b[1000001];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j];//j取-1只是为了判断边界，就如果j为0的话会一直循环下去 next[i+1]=j+1;//匹配到第i+1个时，从第i个开始匹配，例如abcabcd 与 abcabce第3个匹配不上，但是前两个匹配得上 &#125;&#125;void KMP()&#123; for(int i=0,j=0;i&lt;n;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=b[j]) j=next[j]; if(j==m-1) &#123; sum=i-j+1; return; &#125; &#125;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; sum=0; int i; memset(next,0,sizeof(next)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(i=0;i&lt;m;i++) &#123; scanf(&quot;%d&quot;,&amp;b[i]); &#125; Getnext(); KMP(); if(sum==0) sum=-1; printf(&quot;%lld\n&quot;,sum); &#125; return 0;&#125; C - Period当前位循环节的个数，也是板子题，next数组的应用 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[1000001];long long int sum;char b[1000001];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j]; next[i+1]=j+1; &#125;&#125;int main()&#123; int t,i; for(t=1;;t++) &#123; memset(next,0,sizeof(next)); scanf(&quot;%d&quot;,&amp;m); if(m==0) break; scanf(&quot;%s&quot;,b); printf(&quot;Test case #%d\n&quot;,t); Getnext(); for(i=1;i&lt;=m;i++) &#123; if(next[i]&gt;0) &#123; if(i%(i-next[i])==0) &#123; printf(&quot;%d %d\n&quot;,i,i/(i-next[i])); &#125; &#125; &#125; printf(&quot;\n&quot;); &#125; return 0;&#125; D - Power Strings和c差不多，仍然是求循环节的个数。 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[1000001];long long int sum;char b[1000001];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j]; next[i+1]=j+1; &#125;&#125;int main()&#123; while(1) &#123; int i; memset(next,0,sizeof(next)); scanf(&quot;%s&quot;,b); m=strlen(b); if(b[0]==&apos;.&apos;&amp;&amp;m==1) break; Getnext(); if(m%(m-next[m])==0) &#123; printf(&quot;%d\n&quot;,m/(m-next[m])); &#125; else &#123; printf(&quot;1\n&quot;); &#125; &#125; return 0;&#125; E - Count the string子串在母串的个数和，还是偏板子的思维题。 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstring&gt;#include&lt;cstdio&gt;int n,m,next[1000001];int men[1000001];long long int sum;char b[1000001];void Getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;b[i]!=b[j]) j=next[j]; next[i+1]=j+1; &#125;&#125;int main()&#123; int t,i; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; sum=0; scanf(&quot;%d&quot;,&amp;m); scanf(&quot;%s&quot;,b); Getnext(); for(i=1;i&lt;=m;i++) &#123; //printf(&quot;%d &quot;,next[i]); if(next[i]&gt;0) sum++; &#125; printf(&quot;%lld\n&quot;,(sum+m)%10007); &#125; return 0;&#125; F - Cyclic Nacklace在后面添加几个可以让当前字符串构成循环，注意最后一位。next数组的利用。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;string.h&gt;int next[100005],m;char b[100005];void getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(b[i]!=b[j]&amp;&amp;j!=-1) j=next[j]; next[i+1]=j+1; &#125; return;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; memset(next,0,sizeof(next)); scanf(&quot;%s&quot;,b); m=strlen(b); getnext(); if(m%(m-next[m])==0&amp;&amp;next[m]!=0) &#123; printf(&quot;0\n&quot;); &#125; else &#123; int men=m-next[m]; int j=next[m]%men; printf(&quot;%d\n&quot;,men-j); &#125; &#125; return 0; &#125; G - Simpsons’ Hidden Talents最长前后缀,kmp一次就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;string.h&gt;int next[1000005],m,n,sum;char b[1000005],a[1000005];void getnext()&#123; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(b[i]!=b[j]&amp;&amp;j!=-1) j=next[j]; next[i+1]=j+1; &#125; return;&#125;void KMP()&#123; for(int i=0,j=0;i&lt;n;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=b[j]) j=next[j]; sum=j; &#125;&#125;int main()&#123; while(scanf(&quot;%s%s&quot;,b,a)!=EOF) &#123; sum=0; memset(next,0,sizeof(next)); n=strlen(a); m=strlen(b); getnext(); KMP(); for(int i=0;i&lt;=sum;i++) printf(&quot;%c&quot;,b[i]); if(sum&gt;-1) printf(&quot; %d\n&quot;,sum+1); else &#123; printf(&quot;%d\n&quot;,sum+1); &#125; &#125; return 0; &#125; H - Milking Grid求最小覆盖问题，就横竖两次遍历的next数组的应用，然后求他们循环节的最大公倍数，注意，不能超过m,n。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;char a[10005][100];long long int next[10005];int main()&#123; long long int qum=1,sum=1; long long int i,j,m,n; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; scanf(&quot; %c&quot;,&amp;a[i][j]); &#125; &#125; for(i=0;i&lt;n;i++) &#123; memset(next,0,sizeof(next)); next[0]=-1; for(int ii=1,j=0;ii&lt;m;ii++,j++) &#123; while(a[i][ii]!=a[i][j]&amp;&amp;j!=-1) j=next[j]; next[ii+1]=j+1; &#125; sum=((sum/__gcd(sum,(m-next[m])))*((m-next[m]))); if(sum&gt;m) sum=m; &#125; for(i=0;i&lt;m;i++) &#123; memset(next,0,sizeof(next)); next[0]=-1; for(int ii=1,j=0;ii&lt;n;ii++,j++) &#123; while(a[ii][i]!=a[j][i]&amp;&amp;j!=-1) j=next[j]; next[ii+1]=j+1; &#125; qum=((qum/__gcd(qum,(n-next[n])))*(n-next[n])); if(qum&gt;n) qum=n; &#125; printf(&quot;%lld\n&quot;,sum*qum); return 0; &#125; I - Theme Section使输入的字符串满足EAEBE格式的最长E串，next数组的利用，我们可以认为最长为n=next[m]（该字符串的前后缀长度）E（AEB）E，然后从头到尾找是否还有子串满足前后缀长度为n,即找满足EAE格式。如果找不到n–，一直到找到或者n为0 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;string.h&gt;int next[1000005];char a[1000005];int m;void Getnext()&#123; int i,j; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=a[j]) j=next[j]; next[i+1]=j+1; &#125; return;&#125;int main()&#123; int i,j,n,t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%s&quot;,a); m=strlen(a); Getnext(); n=next[m]; for(i=n;i&gt;=0;i--) &#123; for(j=1;j&lt;=m;j++) &#123; if(next[j]==i) break; &#125; if(j&lt;m) &#123; break; &#125; &#125; printf(&quot;%d\n&quot;,i); &#125; return 0;&#125; M - Substring Frequency板子题，子串在母串出现了几次。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;string.h&gt;int next[1000005];char a[1000005];int m;void Getnext()&#123; int i,j; next[0]=-1; for(int i=1,j=0;i&lt;m;i++,j++) &#123; while(j!=-1&amp;&amp;a[i]!=a[j]) j=next[j]; next[i+1]=j+1; &#125; return;&#125;int main()&#123; int i,j,n,t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%s&quot;,a); m=strlen(a); Getnext(); n=next[m]; for(i=n;i&gt;=0;i--) &#123; for(j=1;j&lt;=m;j++) &#123; if(next[j]==i) break; &#125; if(j&lt;m) &#123; break; &#125; &#125; printf(&quot;%d\n&quot;,i); &#125; return 0;&#125;]]></content>
      <categories>
        <category>VJ</category>
      </categories>
      <tags>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
